<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω—ã—Ö —Å—Ç–µ–Ω–¥–æ–≤</title>
    <script type="text/javascript" src="https://me.kis.v2.scr.kaspersky-labs.com/FD126C42-EBFA-4E12-B309-BB3FDD723AC1/main.js?attr=pfTL-b1QD0-HVAB37vBWYBtC4-C-K0U3zIvjZFK_Rp2ru7ywpUzH03RrnA6u1vOfT8uodsUiHK4l-Fqh6BFtLwnqlBgh5GKfxL-Fe2eVudxfq2k56d7Co00e2s_cVthfn1J08YBykKXju8P9kokkvtT8QbvrU44IeXUk92ePDltt0HDPuYP7WZO_jnKmdxgBFQubuBmx-Vz_IT33VzSsU-L6bWIqIxH6BrVoCG2OMoFcg5UOtH7GkmNTTC5v_pLh0N0lfy2gErLnZHOmrVnYKLXnv4KFqn5JyO5FaU_5Me0LVp8ZF3Z6YCgACRybxxYCjoYvDnHjGe-WKB-aeCbXDalOVE5c5pbaLtTmJ4yeAMSHfPAJuKuP0bNdc8tCgJ1k0R8_w593qVd75XNJ7L9deJKP559DpTNtEE8c6loCkVc4vTL4aYYbFiuVzSTO3l7KNUbGtLBhVI3GsZXkETs8tiQ6_ZlQ0MujXfq2UbhXgsbZHBvEnADKZtUyW4FP5R8bOlIKYju-jXugMVxLUHkA923-feNC9Ua0ML9Urm1FO4nUsF7YI0goEr2gUyo1my7NWr-VK9YjPYcxFGSg0Pmn9S0qsHG2x73OdZ3tEcEZTps4Dw6iGoJzsiWN8hguM6JXoeWhyjANOA3QJrNOF3ffqiOw1PJgc7ClpCI3j7QO208W5k9hMAsKSWn1oJHJ5yYJA0w7zgNnFqdGu3aafO7PAxSp0uKSTGA28JKeFC-es7jd_vUWik9iCNVGXBuDvOcZFNftSR_IV_ADELI9fFS962QXSCC3ih16V306YGeCYCLPxJv057zQLcMMWirMrzYrmGGUZKFyeME-umGOoLwQvZF_3dIuQHB5cbwctRJXn-yH1xxuR9bYRvZsMUfMU8O4Z9DmuLAl_Nauh2t21uR9C9gfaXvb5zUr7sV03gsPZIBBQ4R-sHdVIac6TU2VZa0YUd8QLZfRpI97HEadP9lwhwkGgOjU9kqDNplmz53Yd9_lwqvYwI360PHOc_cH_VHlolBrbVbBKG0ZZ7BmuDCXxvXyxhGo392dZEuLuZQNVNVSkNlBITvNo7L-vkEFNJ_2aMEZL5wLHGg2j7j-vtXajPvidVS0yQQvNndZ4esyZ8A6Fz7Matv8CHJHm1QvatedClE5_uxZhy9sAJr6kRfrDt26WuhViRybwBcehjP9Oua036T5xNObjfyHipb-pG2B8QSRC7E28K2Fs9DJmOZ0opoWjbKUCIfakw_aZpoXHbGFrzZAynOCzfDz4kTgMw3b3jgiOL5MOTJF7wZFaS4oRDu1FlDMNoNApriWKgdWflsGV4BnLQGpAte5RA1lJ-NOAFnqyLEk0oMMYhsLxyoWeCfJosL_oNrywYd2UhHkM-g5-JumS717cSqM3js8eO_G3cPF8BacuhbSVFL9HyBtlAF3pJZBNjfsTDV3RgM9NydlihvhKJMECXR97OIfCN03mkx5GmO1_8LeFdqn5HHJifQwtiTvqNTJcRbfwORg4APA5Mh7o-15osViTHGmPzpHzBEimqFNHDY8tXzCkihGRz3SXdX9S3N7hf38_e1TH_lyX2lLPf96sWMzSdHZISOy_i_mt9hdHIRuqVNPYBobUCUQpnW3dETQxI-7lMaGtljQAutQKvMKx7j1z5MVVcIBUYJwrGyfOkPLDQovID7r5U9khLB6pJ6Ax7URvian-tW74_dvax8DKwqnW8cJ0kk1YYFdAbqp28mdh2eiW-uDB8YTkIJ1e7qCL1AhDr0943SdA-iky4Flsv2h22yglyKs9CpOSQ2HuOkNVWqJYIldW_G0RIvaKQmUwK7N4Q-gGdKzyeHi4Hwc7Xlhgpl9u1ZLK51hnz_FdkOlpUDo0A2_Z2LKunBwSPl4IHqN-b5J6xW02bTMsUbez1zuBMKFkKqB3_lo6i8PJojo7yDQzbCwyQu5ktjhS0lpKRPvxCicqT4UWKzy8slcfQ0VNNHTV-HqyLnECH3i_Qcnlb1nSIS4-qfyyYeGem9SkS-1eGPcn6scc60aDrjfGgdk11XqqdFV22YWGZogHNt2s7aGz0B_x-J1qzXqtuc3Xc8Xqrr_nose2Rll0TuohdICnHsycYjOsu46v-GMFaiqZ1Y-M02Ozyr5b8oGutsnSjExa8PhoO_Hozf2CXCsTA8JvE5ZyIaMmbnN1sPJDAL53WQasu4o_wT0YZpsYxA1cCteAx3qbIadCH8KnRTKLvcgdghyMsx025chpLrTzElRB6zV47ujcm3qQPeedtdyxfgV_4yNHO2dlpJXEoHZCY7hioMiWUDW" charset="UTF-8"></script><script type="text/javascript"
        src="https://me.kis.v2.scr.kaspersky-labs.com/FD126C42-EBFA-4E12-B309-BB3FDD723AC1/main.js?attr=CWsvW6mBLlxbaUm9CCL0df5aglL8wTRDjdY9kQJraSHtB_ZKCHFtK2oOmZkR48epGwhNy8i2fAljhRkXASetxuHxNhFqkfYxRKOPDc0ktvVvPfB_u0FN2EvSWWplLyjcYANqPxQwvIByXLbxdYW6hHYHZpW4MDXbyg_Ny5TaVvIRyBbkNwxQuF52evQzbx9gtob_wQQaQKIFa5EsvWLczrmmxOLzBcnnTolxdaaHICnoTmEiXt_E1-lBSGC7iC90omzTVFRRYxQTDxx8UFYJSMHpckJEhfUPlSAFAKA7JyxD2P_Og6de6DgN7kil9NA5UVj4Z3t1rrngTVFoCCBwAeZwS9E0Z8VYvP_yYftpJX2KM-kH07qGhaE9h5nnVcNwoepgSe3gjZJ2lGRBheskLtJ4AtnbAnSaBMotnu5AMkPetT5v0magv7GPGVpV-doXeFW52EIdFCErVSGJCE4hszhqTtOv2SqRCZbjoZ9T-xu7psYYz5PBtnvRHp5uh-8S9-stB3jVFwZvIUYZXwafIqKfQQJRdjCRlRep00BA2gJV_Gfty4ImKRzYz0_K65zFH7n3bjBDpUaPKuZJ4hEaUgQ26xFQ9GrnNvfB5xqGWg8csYFewzmn2n0A0fbOgZEf3XdPr3f5tU8aFpwimPymqdLj3hVFKpz18fTlthO7rOUHs_NpZ5EdkSQdFKtZTlTHjyk8Q59AP_TZuPxgCrfYO6FBx7L_4D7CjoKnbFyBMKyusIxN5kKfhpDIZGjU6TD7c7lmCjOUxPTWeLiarhj642TKcscC92yV3Zg47-nT3ITl-ONeggwycoz1_rhLgsDDjrn34ILxMdbE5ZJp7fHN1xeNPv9xVGMjEFSUKaY1GW8YhGIcAEMClfFFz7UeD4Ayr7GYaYU39U7aKhycDROM30MbgaNzEd-_9PaqZLR2s9d2zmZjUzSWI7Zwzsg4z9dSQmY1XAi-KnXbSram82kv10uJ2DAB5j2OJ_VVdqyUUXMwOgpQXjtyJ6nzDMKb2nwgzlrDvldU7HvfvWeSjMpaju44YYXq-RfiJQ34Ex9RnLOdE3NE3Vrb8-CNMqkmW_iuvftCB7vEWleKXicvn7lVuR_ore7xaOVmLAbjY4gVpV-lB7YrGdVILF0EKxqijRObbmMiKeGbSqkgGFGqhecZr_NhPDX1SolgLXIbdIamgUcQpTpkkbUqM_ZFrnniaBrxByiAf1cI43arVKBp0pok89WNS_rj1_VJt3XHO9Mp_ftTbFtQEcriV3CN7Uad2ir-Nr8jcytQj7wiOAXNrBfbcvENmy96ZUMwNN62oJZNrmoZr0Id-MVvOw0M8858cMmLLWBKBKgGCGArJls5WkESyQ2ctGgYlZwq__-jVbERhEEbbx1gss_p3Oj-GaxAbRLlKQ7WQgflHm3I8bEob4MtyOVd9HHyMlFVcl9ETmcZQEn4NDfza0fc6kRjzEKj0-fO_TGmTPrs-wY_dm2qivVDI_gvHulJe-_MfIIkBx8pc-98uuPL0jdrnF7gGL-Kfm0_CIrwh3jueEFFSxv3jjVlYhEp0xYlujoh-05SBFW2XUuOrSuKyx-XzYPOd7KSGMEghjQa_pNlTiQAMYCGpOGcFtLwRcxW2JDDCDB3iT2AgX9rwTuhoMtZvT3SVpEcQiun2ffuoISpayP4yRgQKcHaIznlVUdvRVulNAteNqdYuadnNZS-hPXC0X5wJ_utgFXcwKYej9uTsY-67XwFkOJB0KWY5LH0kYzSXVh3DkcmuBWwIMDcYK4zR5AqjgArbn6hiIrM8yjq3wtOhR_CAyyCkxN4vQoruzfk8xkJGyRmA7KjsYiPB31i3lLrHskUza9xzxhtAWpLthCg0SpzdyQ1BGl0AsBRiW46NfDnXqp34DewgY_d-cEjZT8fDCivwIcJ1IAv5amTt4rsFWxleQsv07Bzs0ri1zOZpRO-AuQn_cyTwprSRTIx5TFaylruVohZT3sMPhl70ZxjU2Poz2tvCfqvgWOdTp7oCIsqI2ZsPjXrNotdjv2UjUAbwCPOifXdU-PHjT75Ysd-N89M7z7PzLnQUhGpGCZeed-J_1vSQKw8-qTPuOGGDH0yHVN7PX8xyo8noMAQ-G9JXsCnd68z6KhtOOF7hHc8yThwjwAKkUpSIkQVdeeJR4fOQ4ThmoL79gCfcxAUVYgsdpmDEzrDIxmlnIrqVolYVy2mC0GttrRdYhsLEI85mofG5AHXp-Wc"
        charset="UTF-8"></script>
    <script type="text/javascript"
        src="https://me.kis.v2.scr.kaspersky-labs.com/FD126C42-EBFA-4E12-B309-BB3FDD723AC1/main.js?attr=StWmgchRT15nYwIKxtoAI3daP15L2S5F1AdH33c2paRAQieOAzIemM79zfUVKr43PVpHmbn4on_gLL03GfcHYostsLirB4jfFd41Dk39SUGb2qpSZYKkKhm3XIvScoGIndoNI5qJBk6Pyj_8JQWrl9xKFIh7K8Tmod1vvtpkOUCph3EIPIGA1H9X7kBQhDo8dPiDZbVClMqw1NruZP7HtjK61rUPsBl76Ym4M_TYQ4H0aLn67juWYTVQGa7z1BjFGLmlM5Ct4YWEoefkvBYh5K7g2a1e8fzvSK_pc3d8d2T-2saI8yTQBl01ie3ZhiWMOD1uFakEtV6HPQXnXgh32mcYpVVql50SDhtQl1fAyMnqT46iUR8ewS_HKSVc-iJlNn8__YxI97MMFqVVTjiZD3ET7Zb_jw6IzVW6svFQsZAap6CMWGwSJBk0YXTpSe9hp64lpysnf4DV29AZwB6ahmb6KIUCRwvGsoSlEEDPAXnIwI9Z6iHlJCEx4y_m6b9agQVN-tSnjdqRW--KONeU2DowSgebbzF54k4aHdXka_thnV7cGsInMZqmYyLX3h-A5g_kxyscpnnPMWToXywBSKaeccHrmTXkoTIJPPudfvs7lEewvicfpOQXZZ_weX_vu1VgJHiFjHH9g3C5UWXqpHiHWe2Cj-JG5tN752S5yBAic4XeWp1BIraps3zYBouf05d4SujlS2UOQBr9MBhyCXlak6hjrHjyT_Z4E7nFf4Okdz_ehSs9f8l_BrsunazqZzjkZisI0SYRrc54QQgSFa3WrqXDN0M-D8LYlll8yz2twYKQeLRjm1WdVEIjw6lehPcTVor6zfn4vcI6f7nntijgbokEEEatK2LQQC9pF2Jm_eQeaWLOEyoE09MpPRugwmwzFhX8v9f140A5PrLIP1sZnJ7-3PX4JS3EiRN_1P3NioNYQxxbkQP8tzW4L0vqu9M3qG_lcZK6-flFZmBAr9A8K8rWSxwRdvDhwjFhaScbYch6mapVTU9C0KZkttvsmYjYVeVQt8WUjc8qBQA8hSlP3fVD551ZuBPy_wuKTx24AnSCtpEpH2Hc2gRmOux_EH_DP_9wuDJUGB70UCMbLj3Qz_p8fVB-zLMEC9ohwADUmMxu5N3ux8_9SeKCjOak5MszoqzKFOQdNE7vdu2-i8nPdgWmJoMW0IdEEy6uZZmdUcHQsqJUIbA1G_eDnmQLMFXTKdfjY7fGfrng5kf4VXN94ho52gO11-SWSt7P5revur9KJdl-G7RgC_Hn_4X3A8DZEVxUwtfrhv1ME78PSi4HosHgC-qpzmUkbEK7zoETJ0zHWXaSjDFyW4qwR00YUjc7aI6PV8x_boXzBOtpvjCNPHM0dskmA5_OL4JIaCzBXErt7-uHzGRrLt8SwbrrnjEeVS3oRal9msMHYjWRvqI6vrhukH-jxe7mRM6Mna9XewUFfBFVJzb2Vb90caCB7FQ0QUQYSyDQGTNNAaFNsllQ5IGva3Py8JQuhCVpyah_rTuiBm_Sadg8FX34ne9VN3wP57eou2Z22v4T_JriRBNLG5eudtCdAgYXFdBV2qT1uvSyXA-7eUF397_bJHmCLga8S6a0PF8JT8tmnWpngJra8GJ3HWoX5PkBtsWITi3KqRrahcZV-jOsLvLSdd9yuj5sUbkC1W5FBirr8THc4uHq4whyf_rQJ9JfqgpwJ80nKR21CbJAEvbd51JRmCoaGoqqTqjXaMvuNzfGrGqgqUBGiXjUUlLPcqDy63FM3My2AvITsaJ7P3ZyW-um1gbt92F7Z2u4BVH7cvpaioT5eeDRXtJIaFo2N25GzF61ZzaVutQqHPl-aL9T3-gTOTKCVplgxBSiJrKZ1TWY4-4rZAFW6Dx7TNeJyXjU26B8yv7WGzB3xPWEt0j2u1iwJ66rsfO0nAXJaochLHrJHq4bHZCYQsUxgID7KVWLfi2XcUQhWIvC8wQY_esxrkcgWrZ5E6jNj-9nXhksS5oPnSEksBOqT1vil-CtentwQlpUntAJQMBUgDpSw_VxkY_NDPCK17IU6PbCg-Fc7HmkzKDyQROLuP_mP0IuJgQOFgeTCuA1dvYgABvPQ-Qlfik0h8CEPrqQ9hW2tvUnqzBydjIEoautRAZiATtFHNTClGrOeKGEY5hE26CzsFbs1wPQBlJOxtUh1bjLgR0gFHWsDgn0Vbu3H_8JNin1JjZpAzeOrWPAKTU_peCC4VARuy-y7h3aRXWQj6u55yvL3xDs_xeJRA"
        charset="UTF-8"></script>
    <script type="text/javascript"
        src="https://me.kis.v2.scr.kaspersky-labs.com/FD126C42-EBFA-4E12-B309-BB3FDD723AC1/main.js?attr=zNHcrVbNO_C38rPwd1LwFNUtZ3H4hQ5N7dttQb-ekOgcSZ4sgZ5zJ11Z_E67Sj0oDd3reM895Ga_XHHYIeY70uqtrB0B74a264-jwb5RWCE79CAFxE_6xduTO7nsjeNddAQ_QOJ20ufvDwRT2HtxYWm9zy-3KUt0rT5CLeznRe-yrlENgJ2VGFVd_SD99qEzHh4W6sKnwbWIDLeYMtEAqHi5aOD-V41MNpVkYeZ6oQtHW__YflTwLARP5qVrudPpzvr0_VBxgR4St1uhbvwi-oUBCDNpYzSzwwhYrp-54NvLlj_3Lmi7ER5y5cDmans_IcgJfbuTiBETdxcXJ3KDmMW32N-bvRA5lV2FHMx-F_5ndVugYPT16gBltQj5zI-NfX3dR4kHKbzfBEUZOh7B76dR8MUxq0oBZJNNafk3MQdUBsvgJLdobmd1SsZTi5cqjQqWziagP4u6O5Sb9D5ZtirPQYMItTuiFQ2Mlmbjn-ARgM32b3q3RFcs76RxFYIRvuOc0xRTwV5DOCO0PF4QVXYy-fZ2tdKGNbI5qgXPVbYxNSVRj05iYF7Cl9tdUMLXM8bObiW-dHbj4UqbC7R1HTBeN1mMqv18fN01cTolt-UEFOq-whAOTMnfobhGZxGuv_KW2EKl-T3pSOhKtO7w8bzJ9f6WvIWp66Ap8T20lSVSJmCSjUSiNjbNHQOBswigKiIVmpC2t23b2AlY7ldJicTYCHPqFthdTlKsFroh7X2LfrmgWLDUhWlO-v1qlXe0CU8HCtWbSD1m0QNOZiUdHmL7eXd4COV2hcJUjN8lURKfh0cfeejBcpxUykaBk794O2n8w589AVg3LUBgp3TemqTpeOAnhf2XU0qDGVtdpLk5R6Y_Ydv7BUZuaoi3PjNDHs0fyg4hTcOL9GA6n6HBTSIlfzmnKn4QmJgh7QgjklLPWcZOMlffpiYAGUnwrQVQTHnkHlnT4Wihv8mCzsADuCI5k84MEU7m1lHNqsxk4yzLkGkAJBWZa2Vni5Z0GL8jUCzoBwmJramoNXTrFyEK9Ynmyy265QICF_el05pEZ7YoT3k7DZRDGUbJo6IISylHuoyIs-mZtD-34sIPu3VtocG5-aikd_oof_OPfNIfq5HmvbOzuyaKVA8B-8FwitZIJogobFkwnN6PAOCRZpsNBhPeq-lq93JFQgL1SlQ_GgUfk6esdsTaizKzZocole8tJR5MajcuTfV7OTuGL9uymz1vK01iD1NPnEGQHTfBRwk6PbUqMKsV9CDE33_VpaOQXQ9mPkPG_BCxFG20PyfxX2k8E95CNTTY59WgOpwFRd4pM8CW6xk7QvzI4Pb5Cx9S2_U2R_AogmCgrMQ9uXxRFtDujTNiMSRnm2kYbs3_NwzqtBSF8M2K6r_VdEqJ38tZqTE9hHUC6ybjasQ2FU4D0vju6-bmQElkjaGIBqBfdA3qZEEdK6GTz-MwZy4_XyyrNkOxUUBNzhKmcj6w8OdEjG8l-fEvzP8CHKljrA4rcsqCfCR5cN-TTt-Bmqps_C6Mg4Osj8oAUUzt1PDbLQ0KD_QnxY8-6g7vyISiw86k8jhiQoX-dL9K9tfCyPwviwJxO1YvHd09RmdwCXA__30P8oiadNqTBnbeY790IsqfhduonDXGdbPfINO0KwNQvCR0xvzNkckfN91nx_L8pCP0s3rIJGhgeWqWKNVWzRwjkc0RS7dF_cFy2xR0BhNm0jq06qI1YvIUeBqUStv1Rp3kO0zDDkkRsNMwRwoZyflmyi4MHGfX2BKXY8Xl_as1Cfi7A9N6jF9a-xc51ClLQFg5wZUc3EKQWaCbFe2Xjik7pzSpQm0xNtNpikD9hSnhCxk-yJKjxJNB4tl04BJwqfP5hcv2MMEEIKrBYZqvvcFdXbJzQislZWIQA7AlISAC3WeVpT9nYfesqhAd-tROP0FjxdcBxP1V4pq6YCrxxD6Y81POs7nCC3wsh3_biwjvyWdZqHGQLYCpek4EpS7NzM834G2o2Z0hnzOV8g64MiNBn6i3UiSrmmmDyv5q-7a-Nh63GiX45uh7r1W1GpWeB9_7_atCbut82cyelyblfp7l7u1PEErVebpwBX5UrYNBudF5Q6T054_SwtOa08am6fg7HUFXA8rLYCkpkHurjcEB7kZ1bai4cqe44Iyx_Vsqn_BGJTnSE79FsaDxuA51JrS2jR6NgZOj1GxEj1zbK573jhCIcIVVidtybI3q_6f-wPOU"
        charset="UTF-8"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box
        }

        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: #1a1a2e;
            color: #e0e0e0;
            display: flex;
            height: 100vh;
            overflow: hidden
        }

        ::-webkit-scrollbar {
            width: 6px
        }

        ::-webkit-scrollbar-track {
            background: #16213e
        }

        ::-webkit-scrollbar-thumb {
            background: #0f3460;
            border-radius: 3px
        }

        #panel {
            width: 400px;
            min-width: 400px;
            background: #16213e;
            overflow-y: auto;
            padding: 15px;
            border-right: 2px solid #0f3460
        }

        #panel h1 {
            font-size: 18px;
            text-align: center;
            color: #e94560;
            margin-bottom: 15px;
            border-bottom: 1px solid #0f3460;
            padding-bottom: 10px
        }

        .tab-bar {
            display: flex;
            gap: 2px;
            margin-bottom: 12px;
            background: #0d1b3e;
            border-radius: 8px;
            padding: 3px
        }

        .tab-btn {
            flex: 1;
            padding: 7px 4px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 600;
            background: transparent;
            color: #888;
            transition: all .2s
        }

        .tab-btn.active {
            background: #0f3460;
            color: #00e5ff
        }

        .tab-btn:hover:not(.active) {
            color: #ccc
        }

        .tab-content {
            display: none
        }

        .tab-content.active {
            display: block
        }

        .section {
            background: #1a1a3e;
            border: 1px solid #0f3460;
            border-radius: 8px;
            margin-bottom: 10px;
            overflow: hidden
        }

        .section-header {
            background: #0f3460;
            padding: 8px 12px;
            cursor: pointer;
            font-weight: 600;
            font-size: 13px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none
        }

        .section-header:hover {
            background: #1a5276
        }

        .section-header .arrow {
            transition: transform .3s
        }

        .section-header.collapsed .arrow {
            transform: rotate(-90deg)
        }

        .section-body {
            padding: 10px 12px
        }

        .section-body.hidden {
            display: none
        }

        .row {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
            align-items: center
        }

        .row label {
            font-size: 12px;
            color: #aaa;
            min-width: 70px;
            flex-shrink: 0
        }

        .row input[type="number"],
        .row input[type="text"],
        .row select {
            flex: 1;
            padding: 5px 8px;
            background: #0d1b3e;
            border: 1px solid #1a3a6e;
            color: #fff;
            border-radius: 4px;
            font-size: 12px;
            min-width: 0
        }

        .row textarea {
            flex: 1;
            padding: 5px 8px;
            background: #0d1b3e;
            border: 1px solid #1a3a6e;
            color: #fff;
            border-radius: 4px;
            font-size: 12px;
            resize: vertical;
            font-family: inherit
        }

        .row input[type="color"] {
            width: 36px;
            height: 28px;
            border: 1px solid #1a3a6e;
            background: none;
            cursor: pointer;
            border-radius: 4px;
            padding: 1px
        }

        .row input[type="number"]:focus,
        .row select:focus,
        .row textarea:focus {
            border-color: #e94560;
            outline: none
        }

        .row input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #e94560;
            cursor: pointer;
            flex-shrink: 0
        }

        .btn {
            padding: 6px 14px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all .2s
        }

        .btn-primary {
            background: #e94560;
            color: #fff
        }

        .btn-primary:hover {
            background: #c73652
        }

        .btn-secondary {
            background: #0f3460;
            color: #fff
        }

        .btn-secondary:hover {
            background: #1a5276
        }

        .btn-danger {
            background: #8b0000;
            color: #fff
        }

        .btn-danger:hover {
            background: #a00000
        }

        .btn-sm {
            padding: 4px 10px;
            font-size: 11px
        }

        .pocket-item {
            background: #0d1b3e;
            border: 1px solid #1a3a6e;
            border-radius: 6px;
            padding: 8px;
            margin-bottom: 6px;
            transition: border-color .2s, box-shadow .2s
        }

        .pocket-item.selected {
            border-color: #e94560;
            box-shadow: 0 0 8px rgba(233, 69, 96, 0.4)
        }

        .pocket-item .pocket-title {
            font-size: 12px;
            font-weight: 600;
            color: #e94560;
            margin-bottom: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center
        }

        #canvas-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #111
        }

        #toolbar {
            background: #16213e;
            padding: 8px 15px;
            display: flex;
            gap: 10px;
            align-items: center;
            border-bottom: 1px solid #0f3460;
            flex-wrap: wrap
        }

        #toolbar .zoom-info {
            color: #aaa;
            font-size: 12px;
            margin-left: auto
        }

        #toolbar .sep {
            width: 1px;
            height: 24px;
            background: #0f3460
        }

        #canvas-container {
            flex: 1;
            overflow: hidden;
            position: relative;
            cursor: default
        }

        #canvas-container.pan-mode {
            cursor: grab
        }

        #canvas-container.pan-mode .pocket-overlay {
            pointer-events: none
        }

        #canvas-container.panning {
            cursor: grabbing
        }

        #canvas-wrapper {
            position: absolute;
            box-shadow: 0 0 40px rgba(0, 0, 0, .5);
            transform-origin: 0 0;
            overflow: visible
        }

        .pocket-overlay {
            position: absolute;
            cursor: move;
            border: 2px dashed rgba(255, 255, 255, .4);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: rgba(255, 255, 255, .6);
            user-select: none
        }

        .pocket-overlay:hover {
            border-color: #e94560
        }

        .pocket-overlay.selected {
            border-color: #e94560;
            border-style: solid
        }

        .resize-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #e94560;
            border: 1px solid #fff;
            z-index: 10
        }

        .resize-handle.nw {
            top: -5px;
            left: -5px;
            cursor: nw-resize
        }

        .resize-handle.ne {
            top: -5px;
            right: -5px;
            cursor: ne-resize
        }

        .resize-handle.sw {
            bottom: -5px;
            left: -5px;
            cursor: sw-resize
        }

        .resize-handle.se {
            bottom: -5px;
            right: -5px;
            cursor: se-resize
        }

        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, .7);
            z-index: 1000;
            justify-content: center;
            align-items: center
        }

        .modal-overlay.active {
            display: flex
        }

        .modal {
            background: #16213e;
            border: 1px solid #0f3460;
            border-radius: 12px;
            padding: 25px;
            max-width: 400px;
            width: 90%
        }

        .modal h2 {
            color: #e94560;
            margin-bottom: 15px;
            font-size: 16px
        }

        .help-text {
            font-size: 10px;
            color: #666;
            margin-top: 2px;
            margin-bottom: 6px
        }

        .grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            overflow: hidden
        }

        .grid-2 .row label {
            min-width: 20px
        }

        .grid-2 .row input[type="number"] {
            padding: 3px 4px;
            font-size: 11px;
            max-width: 60px
        }

        .sub-controls {
            transition: opacity .3s
        }

        .sub-controls.disabled {
            opacity: .4;
            pointer-events: none
        }

        .snap-line {
            position: absolute;
            z-index: 50;
            pointer-events: none
        }

        .snap-line-h {
            left: 0;
            right: 0;
            height: 1px;
            background: #00e5ff
        }

        .snap-line-v {
            top: 0;
            bottom: 0;
            width: 1px;
            background: #00e5ff
        }

        #snap-badge {
            position: fixed;
            bottom: 15px;
            right: 15px;
            background: #0f3460;
            color: #00e5ff;
            padding: 5px 12px;
            border-radius: 6px;
            font-size: 12px;
            z-index: 100;
            display: none;
            transition: color .15s;
            border: 1px solid #00e5ff
        }

        #snap-badge.active {
            display: block
        }

        .snap-marker {
            position: absolute;
            z-index: 52;
            pointer-events: none;
            font-weight: bold;
            text-shadow: 0 0 3px #000, 0 0 6px #000
        }

        .snap-line-h.snap-center-stand,
        .snap-line-v.snap-center-stand {
            background: #ff6b35
        }

        .snap-line-h.snap-gapmid,
        .snap-line-v.snap-gapmid {
            background: #ffd700
        }

        .snap-line-h.snap-symmetry,
        .snap-line-v.snap-symmetry {
            background: #ff69b4;
            height: 1px
        }

        .type-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px
        }

        .type-table th {
            background: #0f3460;
            padding: 6px 8px;
            text-align: left;
            font-weight: 600;
            color: #aaa
        }

        .type-table td {
            padding: 4px 6px;
            border-bottom: 1px solid #1a3a6e
        }

        .type-table input {
            width: 70px;
            padding: 3px 6px;
            background: #0d1b3e;
            border: 1px solid #1a3a6e;
            color: #fff;
            border-radius: 3px;
            font-size: 12px
        }

        @media (max-width: 900px) {
            body { display: block; height: 100vh; overflow: hidden }
            #panel {
                position: fixed; left: 0; right: 0; bottom: 0; top: auto;
                height: 50vh; width: 100%; min-width: 0;
                border-right: none; border-top: 2px solid #0f3460;
                transform: translateY(100%); transition: transform .25s ease-out; z-index: 50;
            }
            #panel.open { transform: translateY(0) }
            #canvas-area { height: 100vh }
            .mobile-toggle { display: inline-flex !important }
        }
        @media (min-width: 901px) { .mobile-toggle { display: none !important } }
        #canvas-container { touch-action: none }
        .pocket-overlay { touch-action: none }
        #touch-snap-layer {
            position: absolute;
            pointer-events: none;
            z-index: 200;
            transform-origin: 0 0;
            overflow: visible;
        }

    </style>
</head>

<body>

    <div id="panel">
        <h1>üñº –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä —Å—Ç–µ–Ω–¥–æ–≤</h1>
        <div class="tab-bar">
            <button class="tab-btn active" onclick="switchTab('main')">üìê –°—Ç–µ–Ω–¥</button>
            <button class="tab-btn" onclick="switchTab('pockets')">üìÇ –ö–∞—Ä–º–∞–Ω—ã</button>
            <button class="tab-btn" onclick="switchTab('types')">üìè –¢–∏–ø—ã</button>
            <button class="tab-btn" onclick="switchTab('settings')">‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏</button>
        </div>

        <!-- TAB: MAIN -->
        <div class="tab-content active" id="tab-main">
            <div class="section">
                <div class="section-header" onclick="toggleSection(this)">üìê –†–∞–∑–º–µ—Ä —Å—Ç–µ–Ω–¥–∞ <span class="arrow">‚ñº</span>
                </div>
                <div class="section-body">
                    <div class="row"><label>–®–∏—Ä–∏–Ω–∞ (–º–º)</label><input type="number" id="standW" value="1600" min="100"
                            max="5000" onchange="rebuild()"></div>
                    <div class="row"><label>–í—ã—Å–æ—Ç–∞ (–º–º)</label><input type="number" id="standH" value="1200" min="100"
                            max="5000" onchange="rebuild()"></div>
                    <div class="row"><label>–¶–≤–µ—Ç —Ñ–æ–Ω–∞</label><input type="color" id="standColor" value="#ffffff"
                            onchange="rebuild()"></div>
                    <div class="row"><label>–°–∫—Ä—É–≥–ª–µ–Ω–∏–µ</label><input type="number" id="standRadius" value="0" min="0"
                            max="100" onchange="rebuild()"></div>
                </div>
            </div>
            <div class="section">
                <div class="section-header" onclick="toggleSection(this)">üè∑ –®–∞–ø–∫–∞ —Å—Ç–µ–Ω–¥–∞ <span class="arrow">‚ñº</span>
                </div>
                <div class="section-body">
                    <div class="row"><label>–í—ã—Å–æ—Ç–∞ (–º–º)</label><input type="number" id="headerH" value="150" min="0"
                            max="1000" onchange="rebuild()"></div>
                    <div class="row"><label>–¶–≤–µ—Ç —à–∞–ø–∫–∏</label><input type="color" id="headerColor" value="#8B0000"
                            onchange="rebuild()"></div>
                    <div class="row"><label>–¢–µ–∫—Å—Ç</label><textarea id="headerText" rows="2"
                            oninput="rebuild()">–ò–ù–§–û–†–ú–ê–¶–ò–û–ù–ù–´–ô –°–¢–ï–ù–î</textarea></div>
                    <div class="row"><label>–®—Ä–∏—Ñ—Ç</label><select id="headerFont" onchange="rebuild()">
                            <option value="Arial">Arial</option>
                            <option value="Times New Roman" selected>Times New Roman</option>
                            <option value="Verdana">Verdana</option>
                            <option value="Georgia">Georgia</option>
                            <option value="Courier New">Courier New</option>
                            <option value="Impact">Impact</option>
                            <option value="Tahoma">Tahoma</option>
                        </select></div>
                    <div class="row"><label>–í—ã—Å. —Ç–µ–∫—Å—Ç–∞</label><input type="number" id="headerFontH" value="46" min="5"
                            max="200" onchange="rebuild()"></div>
                    <div class="row"><label>–®–∏—Ä. –±—É–∫–≤</label><input type="number" id="headerFontW" value="0" min="0"
                            max="200" step="0.5" onchange="rebuild()"></div>
                    <div class="row"><label>–ú–µ–∂—Å—Ç—Ä–æ—á–Ω—ã–π</label><input type="number" id="headerLineH" value="0" min="0"
                            max="200" onchange="rebuild()"></div>
                    <div class="row"><label>–¶–≤–µ—Ç —Ç–µ–∫—Å—Ç–∞</label><input type="color" id="headerTextColor" value="#F0FF00"
                            onchange="rebuild()"></div>
                    <div class="row"><label>–ñ–∏—Ä–Ω—ã–π</label><select id="headerBold" onchange="rebuild()">
                            <option value="bold" selected>–î–∞</option>
                            <option value="normal">–ù–µ—Ç</option>
                        </select></div>
                    <div class="row"><label>–û—Ç—Å—Ç. —Å–≤–µ—Ä—Ö—É</label><input type="number" id="headerPadTop" value="0" min="0"
                            onchange="rebuild()"></div>
                    <div class="row"><label>–û—Ç—Å—Ç. —Å–Ω–∏–∑—É</label><input type="number" id="headerPadBottom" value="0"
                            min="0" onchange="rebuild()"></div>
                    <div class="row"><label>–û—Ç—Å—Ç. –ª–µ–≤.</label><input type="number" id="headerPadLeft" value="0" min="0"
                            onchange="rebuild()"></div>
                    <div class="row"><label>–û—Ç—Å—Ç. –ø—Ä–∞–≤.</label><input type="number" id="headerPadRight" value="0"
                            min="0" onchange="rebuild()"></div>
                </div>
            </div>
            <div class="section">
                <div class="section-header" onclick="toggleSection(this)">üìè –û—Ç—Å—Ç—É–ø—ã –∫–æ–Ω—Ç–µ–Ω—Ç–∞ <span
                        class="arrow">‚ñº</span></div>
                <div class="section-body">
                    <div class="row"><label>–°–≤–µ—Ä—Ö—É</label><input type="number" id="contentPadTop" value="20" min="0"
                            onchange="relayoutPockets()"></div>
                    <div class="row"><label>–°–Ω–∏–∑—É</label><input type="number" id="contentPadBottom" value="20" min="0"
                            onchange="relayoutPockets()"></div>
                    <div class="row"><label>–°–ª–µ–≤–∞</label><input type="number" id="contentPadLeft" value="20" min="0"
                            onchange="relayoutPockets()"></div>
                    <div class="row"><label>–°–ø—Ä–∞–≤–∞</label><input type="number" id="contentPadRight" value="20" min="0"
                            onchange="relayoutPockets()"></div>
                    <div class="row"><label>–ó–∞–∑–æ—Ä X</label><input type="number" id="gapX" value="15" min="0"
                            onchange="relayoutPockets()"></div>
                    <div class="row"><label>–ó–∞–∑–æ—Ä Y</label><input type="number" id="gapY" value="15" min="0"
                            onchange="relayoutPockets()"></div>
                </div>
            </div>
            <div class="section">
                <div class="section-header" onclick="toggleSection(this)">üñº –†–∞–º–∫–∞ —Å—Ç–µ–Ω–¥–∞ <span class="arrow">‚ñº</span>
                </div>
                <div class="section-body">
                    <div class="row"><label>–í–∫–ª—é—á–µ–Ω–∞</label><input type="checkbox" id="borderEnabled"
                            onchange="rebuild()"></div>
                    <div class="sub-controls" id="borderControls">
                        <div class="row"><label>–¢–æ–ª—â–∏–Ω–∞</label><input type="number" id="borderW" value="2" min="0"
                                max="20" step="0.5" onchange="rebuild()"></div>
                        <div class="row"><label>–¶–≤–µ—Ç</label><input type="color" id="borderColor" value="#8B0000"
                                onchange="rebuild()"></div>
                        <div class="row"><label>–û—Ç—Å—Ç—É–ø</label><input type="number" id="borderInset" value="0" min="0"
                                max="50" onchange="rebuild()"></div>
                    </div>
                </div>
            </div>
            <div style="text-align:center;margin-top:10px"><button class="btn btn-primary" onclick="showExport()"
                    style="font-size:14px;padding:10px 30px">üíæ –≠–∫—Å–ø–æ—Ä—Ç</button></div>
        </div>

        <!-- TAB: POCKETS -->
        <div class="tab-content" id="tab-pockets">
            <div class="section">
                <div class="section-header" onclick="toggleSection(this)">üìÇ –°–æ–∑–¥–∞–Ω–∏–µ –∫–∞—Ä–º–∞–Ω–æ–≤ <span
                        class="arrow">‚ñº</span>
                </div>
                <div class="section-body">
                    <div class="row" style="margin-bottom:10px"><label>–ê–≤—Ç–æ-—Å–µ—Ç–∫–∞</label>
                        <input type="number" id="gridCols" value="3" min="1" max="10" style="width:50px">
                        <span style="font-size:12px;color:#aaa">√ó</span>
                        <input type="number" id="gridRows" value="2" min="1" max="10" style="width:50px">
                        <button class="btn btn-primary btn-sm" onclick="autoGrid()">–°–æ–∑–¥–∞—Ç—å</button>
                    </div>
                    <div class="row"><label>–¢–∏–ø –ø–æ —É–º–æ–ª—á.</label><select id="defPocketType"
                            onchange="applyTypeDefaults()">
                            <option value="A3">A3</option>
                            <option value="A4">A4</option>
                            <option value="A5" selected>A5</option>
                            <option value="A6">A6</option>
                            <option value="custom">–°–≤–æ–π</option>
                        </select></div>
                    <div class="row"><label>–û—Ä–∏–µ–Ω—Ç–∞—Ü–∏—è</label><select id="pocketOrientation"
                            onchange="applyOrientation()">
                            <option value="portrait" selected>–í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ</option>
                            <option value="landscape">–ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ</option>
                        </select></div>
                    <div class="row"><label>–®. –∫–∞—Ä–º.</label><input type="number" id="defPocketW" value="148"
                            min="20"><label>–í.
                            –∫–∞—Ä–º.</label><input type="number" id="defPocketH" value="210" min="20"></div>
                    <div class="row"><label>–¶–≤–µ—Ç</label><input type="color" id="defPocketColor"
                            value="#FFFFFF"><label>–û–±–≤–æ–¥–∫–∞</label><input type="color" id="defPocketStroke"
                            value="#000000"></div>
                    <div class="row"><label>–¢–æ–ª—â. –æ–±–≤.</label><input type="number" id="defPocketStrokeW" value="1"
                            min="0" max="10" step="0.1"><label>–°–∫—Ä—É–≥–ª.</label><input type="number" id="defPocketRadius"
                            value="0" min="0" max="50"></div>
                </div>
            </div>
            <div class="section">
                <div class="section-header" onclick="toggleSection(this)"> –ü–æ–¥–ø–∏—Å–∏ –∫–∞—Ä–º–∞–Ω–æ–≤ <span class="arrow">‚ñº</span>
                </div>
                <div class="section-body">
                    <div class="row"><label>–ü–æ–ª–æ–∂–µ–Ω–∏–µ</label><select id="pocketLabelPos" onchange="rebuild()">
                            <option value="top">–°–≤–µ—Ä—Ö—É</option>
                            <option value="bottom">–°–Ω–∏–∑—É</option>
                            <option value="none" selected>–ù–µ—Ç</option>
                        </select></div>
                    <div class="row"><label>–®—Ä–∏—Ñ—Ç</label><select id="pocketFont" onchange="rebuild()">
                            <option value="Arial">Arial</option>
                            <option value="Times New Roman" selected>Times New Roman</option>
                            <option value="Verdana">Verdana</option>
                            <option value="Georgia">Georgia</option>
                        </select></div>
                    <div class="row"><label>–í—ã—Å. —à—Ä–∏—Ñ—Ç–∞</label><input type="number" id="pocketFontH" value="8" min="3"
                            max="50" onchange="rebuild()"><label>–®–∏—Ä.</label><input type="number" id="pocketFontW"
                            value="0" min="0" max="50" onchange="rebuild()"></div>
                    <div class="row"><label>–¶–≤–µ—Ç –ø–æ–¥–ø.</label><input type="color" id="pocketLabelColor" value="#F0FF00"
                            onchange="rebuild()"><label>–û—Ç—Å—Ç—É–ø</label><input type="number" id="pocketLabelGap" value="5"
                            min="0" max="50" onchange="rebuild()"></div>
                </div>
            </div>
            <hr style="border-color:#0f3460;margin:10px 0">
            <div style="display:flex;gap:5px;margin-bottom:8px"><button class="btn btn-secondary btn-sm"
                    onclick="addPocket()">+ –ö–∞—Ä–º–∞–Ω</button><button class="btn btn-danger btn-sm"
                    onclick="clearPockets()">–û—á–∏—Å—Ç–∏—Ç—å</button></div>
            <div id="pocketsList"></div>
        </div>

        <!-- TAB: TYPES -->
        <div class="tab-content" id="tab-types">
            <div class="section">
                <div class="section-header">üìè –†–∞–∑–º–µ—Ä—ã —Ç–∏–ø–æ–≤ –∫–∞—Ä–º–∞–Ω–æ–≤</div>
                <div class="section-body">
                    <p class="help-text">–†–µ–¥–∞–∫—Ç–∏—Ä—É–π—Ç–µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ —Ä–∞–∑–º–µ—Ä—ã –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ç–∏–ø–∞ (–º–º). –ò–∑–º–µ–Ω–µ–Ω–∏—è –º–≥–Ω–æ–≤–µ–Ω–Ω–æ
                        –ø—Ä–∏–º–µ–Ω—è—é—Ç—Å—è –∫–æ –≤—Å–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º –∫–∞—Ä–º–∞–Ω–∞–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–µ–≥–æ —Ç–∏–ø–∞.</p>
                    <table class="type-table">
                        <tr>
                            <th>–¢–∏–ø</th>
                            <th>–®–∏—Ä–∏–Ω–∞</th>
                            <th>–í—ã—Å–æ—Ç–∞</th>
                            <th>–ö–æ–ª-–≤–æ</th>
                        </tr>
                        <tr>
                            <td>A3 <span id="countA3" style="color:#e94560;font-size:10px"></span></td>
                            <td><input type="number" id="typeA3W" value="297" oninput="onTypeChange()"></td>
                            <td><input type="number" id="typeA3H" value="420" oninput="onTypeChange()"></td>
                        </tr>
                        <tr>
                            <td>A4 <span id="countA4" style="color:#e94560;font-size:10px"></span></td>
                            <td><input type="number" id="typeA4W" value="210" oninput="onTypeChange()"></td>
                            <td><input type="number" id="typeA4H" value="297" oninput="onTypeChange()"></td>
                        </tr>
                        <tr>
                            <td>A5 <span id="countA5" style="color:#e94560;font-size:10px"></span></td>
                            <td><input type="number" id="typeA5W" value="148" oninput="onTypeChange()"></td>
                            <td><input type="number" id="typeA5H" value="210" oninput="onTypeChange()"></td>
                        </tr>
                        <tr>
                            <td>A6 <span id="countA6" style="color:#e94560;font-size:10px"></span></td>
                            <td><input type="number" id="typeA6W" value="105" oninput="onTypeChange()"></td>
                            <td><input type="number" id="typeA6H" value="148" oninput="onTypeChange()"></td>
                        </tr>
                    </table>
                </div>
            </div>
        </div>

        <!-- TAB: SETTINGS -->
        <div class="tab-content" id="tab-settings">
            <div class="section">
                <div class="section-header" onclick="toggleSection(this)">üî≤ –°–µ—Ç–∫–∞ <span class="arrow">‚ñº</span></div>
                <div class="section-body">
                    <div class="row"><label>–ü–æ–∫–∞–∑–∞—Ç—å</label><input type="checkbox" id="gridEnabled"
                            onchange="rebuild()"></div>
                    <div class="row"><label>–®–∞–≥ (–º–º)</label><input type="number" id="gridStep" value="10" min="1"
                            max="200" onchange="rebuild()"></div>
                    <div class="row"><label>–ö—Ä—É–ø–Ω—ã–π —à–∞–≥</label><input type="number" id="gridMajor" value="5" min="1"
                            max="50" onchange="rebuild()"></div>
                    <div class="row"><label>–¶–≤–µ—Ç</label><input type="color" id="gridColor" value="#444466"
                            onchange="rebuild()">
                    </div>
                    <div class="row"><label>–¶–≤–µ—Ç –∫—Ä—É–ø–Ω–æ–π</label><input type="color" id="gridMajorColor" value="#555588"
                            onchange="rebuild()"></div>
                    <div class="row"><label>–ù–∞—á–∞–ª–æ X</label><input type="number" id="gridOriginX" value="0" min="0"
                            onchange="rebuild()"></div>
                    <div class="row"><label>–ù–∞—á–∞–ª–æ Y</label><input type="number" id="gridOriginY" value="0" min="0"
                            onchange="rebuild()"></div>
                </div>
            </div>
            <div class="section">
                <div class="section-header" onclick="toggleSection(this)">üß≤ –ü—Ä–∏–≤—è–∑–∫–∞ <span class="arrow">‚ñº</span></div>
                <div class="section-body">
                    <div class="row"><label>–í–∫–ª—é—á–µ–Ω–∞</label><input type="checkbox" id="snapEnabled" checked></div>
                    <div class="row"><label>–†–∞–¥–∏—É—Å (–º–º)</label><input type="number" id="snapRadius" value="5" min="1"
                            max="50">
                    </div>
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:2px;margin-top:4px">
                        <label
                            style="font-size:11px;color:#ccc;display:flex;align-items:center;gap:4px;cursor:pointer"><input
                                type="checkbox" id="snapGrid" checked
                                style="width:14px;height:14px;accent-color:#00e5ff"> –ö
                            —Å–µ—Ç–∫–µ</label>
                        <label
                            style="font-size:11px;color:#ccc;display:flex;align-items:center;gap:4px;cursor:pointer"><input
                                type="checkbox" id="snapEdges" checked
                                style="width:14px;height:14px;accent-color:#00e5ff"> –ö
                            –∫—Ä–∞—è–º</label>
                        <label
                            style="font-size:11px;color:#ccc;display:flex;align-items:center;gap:4px;cursor:pointer"><input
                                type="checkbox" id="snapPockets" checked
                                style="width:14px;height:14px;accent-color:#00e5ff"> –ö
                            –∫–∞—Ä–º–∞–Ω–∞–º</label>
                        <label
                            style="font-size:11px;color:#ccc;display:flex;align-items:center;gap:4px;cursor:pointer"><input
                                type="checkbox" id="snapCenter" checked
                                style="width:14px;height:14px;accent-color:#00e5ff"> –ö
                            —Ü–µ–Ω—Ç—Ä–∞–º</label>
                        <label
                            style="font-size:11px;color:#ccc;display:flex;align-items:center;gap:4px;cursor:pointer"><input
                                type="checkbox" id="snapMidpoints" checked
                                style="width:14px;height:14px;accent-color:#00e5ff"> –ö
                            —Å–µ—Ä–µ–¥–∏–Ω–∞–º</label>
                        <label
                            style="font-size:11px;color:#ccc;display:flex;align-items:center;gap:4px;cursor:pointer"><input
                                type="checkbox" id="snapPadding" checked
                                style="width:14px;height:14px;accent-color:#00e5ff"> –ö
                            –æ—Ç—Å—Ç—É–ø–∞–º</label>
                    <label style="font-size:11px;color:#ccc;display:flex;align-items:center;gap:4px;cursor:pointer"><input
                                type="checkbox" id="snapGapMid" checked
                                style="width:14px;height:14px;accent-color:#ffd700"> –°–µ—Ä–µ–¥.
                            –ø—Ä–æ–º–µ–∂—É—Ç–∫–æ–≤</label>
                    <label style="font-size:11px;color:#ccc;display:flex;align-items:center;gap:4px;cursor:pointer"><input
                                type="checkbox" id="snapSymmetry" checked
                                style="width:14px;height:14px;accent-color:#ff69b4"> –°–∏–º–º–µ—Ç—Ä–∏—è</label>
                    </div>
                </div>
            </div>
            <div class="section">
                <div class="section-header" onclick="toggleSection(this)">üìê –†–∞–∑–º–µ—Ä–Ω—ã–µ –ª–∏–Ω–∏–∏ <span
                        class="arrow">‚ñº</span></div>
                <div class="section-body">
                    <div class="row"><label>–ü–æ–∫–∞–∑–∞—Ç—å</label><input type="checkbox" id="dimEnabled" onchange="rebuild()">
                    </div>
                    <div class="row"><label>–¶–≤–µ—Ç</label><input type="color" id="dimColor" value="#00FF00"
                            onchange="rebuild()">
                    </div>
                    <div class="row"><label>–†–∞–∑–º–µ—Ä —Ç–µ–∫—Å—Ç–∞</label><input type="number" id="dimFontSize" value="20"
                            min="3" max="20" onchange="rebuild()"></div>
                    <div class="row"><label>–û—Ç—Å—Ç—É–ø –ª–∏–Ω–∏–π</label><input type="number" id="dimOffset" value="12" min="5"
                            max="50" onchange="rebuild()"></div>
                    <div class="row"><label>–¢–æ–ª—â. –ª–∏–Ω–∏–π</label><input type="number" id="dimLineWidth" value="1"
                            min="0.1" max="5" step="0.1" onchange="rebuild()"></div>
                    <div class="row"><label>–¢–æ–ª—â. –≤—ã–Ω–æ—Å–Ω—ã—Ö</label><input type="number" id="dimExtWidth" value="1"
                            min="0.1" max="3" step="0.1" onchange="rebuild()"></div>
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:2px;margin-top:4px">
                        <label
                            style="font-size:11px;color:#ccc;display:flex;align-items:center;gap:4px;cursor:pointer"><input
                                type="checkbox" id="dimHGaps" checked onchange="rebuild()"
                                style="width:14px;height:14px;accent-color:#00e5ff"> –ó–∞–∑–æ—Ä—ã –≥–æ—Ä–∏–∑.</label>
                        <label
                            style="font-size:11px;color:#ccc;display:flex;align-items:center;gap:4px;cursor:pointer"><input
                                type="checkbox" id="dimVGaps" checked onchange="rebuild()"
                                style="width:14px;height:14px;accent-color:#00e5ff"> –ó–∞–∑–æ—Ä—ã –≤–µ—Ä—Ç.</label>
                        <label
                            style="font-size:11px;color:#ccc;display:flex;align-items:center;gap:4px;cursor:pointer"><input
                                type="checkbox" id="dimHeader" checked onchange="rebuild()"
                                style="width:14px;height:14px;accent-color:#00e5ff"> –®–∞–ø–∫–∞</label>
                        <label
                            style="font-size:11px;color:#ccc;display:flex;align-items:center;gap:4px;cursor:pointer"><input
                                type="checkbox" id="dimHeaderText" checked onchange="rebuild()"
                                style="width:14px;height:14px;accent-color:#00e5ff"> –¢–µ–∫—Å—Ç —à–∞–ø–∫–∏</label>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- CANVAS -->
    <div id="canvas-area">
        <div id="toolbar">
            <button class="btn btn-secondary btn-sm mobile-toggle" style="display:none" onclick="document.getElementById('panel').classList.toggle('open')">‚öôÔ∏è</button>
            <button class="btn btn-secondary btn-sm" onclick="zoomIn()">üîç+</button>
            <button class="btn btn-secondary btn-sm" onclick="zoomOut()">üîç‚àí</button>
            <button class="btn btn-secondary btn-sm" onclick="zoomFit()">–ü–æ —Ä–∞–∑–º–µ—Ä—É</button>
            <button class="btn btn-secondary btn-sm" onclick="zoomReset()">100%</button>
            <div class="sep"></div>
            <button class="btn btn-sm" id="btnGrid"
                onclick="document.getElementById('gridEnabled').checked=!chk('gridEnabled');rebuild();"
                style="background:#333;color:#aaa">–°–µ—Ç–∫–∞</button>
            <button class="btn btn-sm" id="btnSnap"
                onclick="document.getElementById('snapEnabled').checked=!chk('snapEnabled');rebuild();"
                style="background:#333;color:#aaa">–ü—Ä–∏–≤—è–∑–∫–∞</button>
            <button class="btn btn-sm" id="btnDim"
                onclick="document.getElementById('dimEnabled').checked=!chk('dimEnabled');rebuild();"
                style="background:#333;color:#aaa">–†–∞–∑–º–µ—Ä—ã</button>
            <div class="sep"></div>
            <button class="btn btn-sm" id="btnPan" onclick="togglePanMode()" style="background:#333;color:#aaa">‚úã
                –†—É–∫–∞</button>
            <span class="zoom-info" id="zoomInfo">100%</span>
        </div>
        <div id="canvas-container">
            <div id="canvas-wrapper"></div>
            <div id="touch-snap-layer"></div>
        </div>
    </div>
    <div id="snap-badge"></div>

    <!-- Export Modal -->
    <div class="modal-overlay" id="exportModal">
        <div class="modal">
            <h2>üíæ –≠–∫—Å–ø–æ—Ä—Ç</h2>
            <div style="text-align:center"><button class="btn btn-primary" onclick="exportSVG()">üìÑ SVG</button> <button
                    class="btn btn-secondary" onclick="exportPDF()">üìë PDF</button> <button class="btn btn-secondary"
                    onclick="exportPNG()">üñº PNG</button></div>
            <div style="text-align:center;margin-top:15px"><button class="btn btn-danger btn-sm"
                    onclick="closeExport()">–ó–∞–∫—Ä—ã—Ç—å</button></div>
        </div>
    </div>

    <script>
        let pockets = [], zoom = 0.5, selectedPocket = -1, dragState = null, lastGridCols = 3, lastGridRows = 2, snapLines = [];
        let panMode = false, panState = null, panX = 0, panY = 0, spaceDown = false;
        let touchDragState = null;
        const MM2PX = 3.7795275591;

        function val(id) { return document.getElementById(id).value }
        function num(id) { return parseFloat(document.getElementById(id).value) || 0 }
        function chk(id) { return document.getElementById(id).checked }
        function escXml(s) { return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;') }
        function toggleSection(h) { h.classList.toggle('collapsed'); h.nextElementSibling.classList.toggle('hidden') }

        // ===== TABS =====
        function switchTab(name) {
            document.querySelectorAll('.tab-btn').forEach((b, i) => b.classList.toggle('active', b.textContent.includes({ main: '–°—Ç–µ–Ω–¥', pockets: '–ö–∞—Ä–º–∞–Ω—ã', types: '–¢–∏–ø—ã', settings: '–ù–∞—Å—Ç—Ä–æ–π–∫–∏' }[name])));
            document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
            document.getElementById('tab-' + name).classList.add('active');
        }

        // ===== TYPE SIZES =====
        function getTypeSize(type) {
            const sizes = { A3: [num('typeA3W'), num('typeA3H')], A4: [num('typeA4W'), num('typeA4H')], A5: [num('typeA5W'), num('typeA5H')], A6: [num('typeA6W'), num('typeA6H')] };
            return sizes[type] || null;
        }
        function applyTypeDefaults() {
            const t = val('defPocketType'), s = getTypeSize(t);
            if (s) {
                const o = val('pocketOrientation');
                document.getElementById('defPocketW').value = o === 'landscape' ? Math.max(s[0], s[1]) : Math.min(s[0], s[1]);
                document.getElementById('defPocketH').value = o === 'landscape' ? Math.min(s[0], s[1]) : Math.max(s[0], s[1]);
            }
        }
        function applyOrientation() {
            const w = num('defPocketW'), h = num('defPocketH'), o = val('pocketOrientation');
            if (o === 'landscape' && h > w) { document.getElementById('defPocketW').value = h; document.getElementById('defPocketH').value = w }
            else if (o === 'portrait' && w > h) { document.getElementById('defPocketW').value = h; document.getElementById('defPocketH').value = w }
        }
        function updateTypeCounts() {
            ['A3', 'A4', 'A5', 'A6'].forEach(t => {
                const el = document.getElementById('count' + t);
                if (el) {
                    const c = pockets.filter(p => p.type === t).length;
                    el.textContent = c > 0 ? '(' + c + ')' : '';
                }
            });
        }
        function onTypeChange() {
            // Auto-update all existing pockets of changed types
            ['A3', 'A4', 'A5', 'A6'].forEach(t => {
                const s = getTypeSize(t);
                if (!s) return;
                pockets.forEach(p => {
                    if (p.type !== t) return;
                    const isLand = p.w > p.h;
                    p.w = isLand ? Math.max(s[0], s[1]) : Math.min(s[0], s[1]);
                    p.h = isLand ? Math.min(s[0], s[1]) : Math.max(s[0], s[1]);
                });
            });
            rebuild();
        }
        function changePocketType(idx, type) {
            const p = pockets[idx], s = getTypeSize(type);
            if (s) {
                const isLand = p.w > p.h;
                p.w = isLand ? Math.max(s[0], s[1]) : Math.min(s[0], s[1]);
                p.h = isLand ? Math.min(s[0], s[1]) : Math.max(s[0], s[1]);
            }
            p.type = type;
            rebuild();
        }

        // ===== TEXT MEASURE =====
        function measureCharWidth(ff, fw, fs) { const c = document.createElement('canvas').getContext('2d'); c.font = `${fw} ${fs * MM2PX}px '${ff}'`; const r = '–ê–ë–í–ì–î–ï–ñ–ó–ò–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–≠–Æ–Ø'; return (c.measureText(r).width / r.length) / MM2PX }
        function calcScaleX(dw, ff, fw, fs) { if (!dw || dw <= 0) return 1; const n = measureCharWidth(ff, fw, fs); return n > 0 ? dw / n : 1 }

        // ===== GRID LAYOUT =====
        function computeGridPositions(cols, rows, pw, ph) {
            const padT = num('contentPadTop'), padL = num('contentPadLeft'), gx = num('gapX'), gy = num('gapY'), hh = num('headerH');
            const le = val('pocketLabelPos') !== 'none' ? num('pocketFontH') + num('pocketLabelGap') : 0;
            const pos = [];
            for (let r = 0; r < rows; r++)for (let c = 0; c < cols; c++)pos.push({ x: padL + c * (pw + gx), y: hh + padT + r * (ph + gy + le) });
            return pos;
        }
        function autoGrid() {
            const cols = parseInt(val('gridCols')) || 3, rows = parseInt(val('gridRows')) || 2;
            lastGridCols = cols; lastGridRows = rows;
            const pw = num('defPocketW'), ph = num('defPocketH'), pos = computeGridPositions(cols, rows, pw, ph);
            const t = val('defPocketType'), o = val('pocketOrientation');
            pockets = pos.map((p, i) => ({ x: p.x, y: p.y, w: pw, h: ph, color: val('defPocketColor'), stroke: val('defPocketStroke'), strokeW: num('defPocketStrokeW'), radius: num('defPocketRadius'), label: '–î–æ–∫—É–º–µ–Ω—Ç ' + (i + 1), type: t, orientation: o }));
            rebuild();
        }
        function relayoutPockets() {
            if (pockets.length && pockets.length === lastGridCols * lastGridRows) {
                const pw = pockets[0].w, ph = pockets[0].h;
                computeGridPositions(lastGridCols, lastGridRows, pw, ph).forEach((p, i) => { if (i < pockets.length) { pockets[i].x = p.x; pockets[i].y = p.y } });
            }
            rebuild();
        }
        function addPocket() {
            pockets.push({ x: num('contentPadLeft'), y: num('headerH') + num('contentPadTop'), w: num('defPocketW'), h: num('defPocketH'), color: val('defPocketColor'), stroke: val('defPocketStroke'), strokeW: num('defPocketStrokeW'), radius: num('defPocketRadius'), label: '–î–æ–∫—É–º–µ–Ω—Ç ' + (pockets.length + 1), type: val('defPocketType'), orientation: val('pocketOrientation') });
            rebuild();
        }
        function clearPockets() { pockets = []; selectedPocket = -1; rebuild() }
        function removePocket(i) { pockets.splice(i, 1); if (selectedPocket === i) selectedPocket = -1; else if (selectedPocket > i) selectedPocket--; rebuild() }
        function togglePocketOrientation(i) { const p = pockets[i]; const tmp = p.w; p.w = p.h; p.h = tmp; p.orientation = p.w > p.h ? 'landscape' : 'portrait'; rebuild() }

        function renderPocketList() {
            const el = document.getElementById('pocketsList'); let html = '';
            pockets.forEach((p, i) => {
                const isL = p.w > p.h;
                const typeOpts = ['A3', 'A4', 'A5', 'A6', 'custom'].map(t => `<option value="${t}"${p.type === t ? ' selected' : ''}>${t}</option>`).join('');
                html += `<div class="pocket-item${i === selectedPocket ? ' selected' : ''}" data-pocket-idx="${i}" onclick="if(event.target.tagName!=='INPUT'&&event.target.tagName!=='SELECT'&&event.target.tagName!=='BUTTON'){selectedPocket=${i};rebuild()}"><div class="pocket-title"><span>–ö–∞—Ä–º–∞–Ω ${i + 1} ${isL ? '‚Üî' : '‚Üï'}</span><span>
      <button class="btn btn-secondary btn-sm" onclick="togglePocketOrientation(${i})" title="–ü–æ–≤–µ—Ä–Ω—É—Ç—å">üîÑ</button>
      <button class="btn btn-danger btn-sm" onclick="removePocket(${i})">‚úï</button></span></div>
      <div class="row"><label>–¢–∏–ø</label><select onchange="changePocketType(${i},this.value)" style="flex:1;padding:4px;background:#0d1b3e;border:1px solid #1a3a6e;color:#fff;border-radius:4px;font-size:12px">${typeOpts}</select></div>
      <div class="row"><label>–ü–æ–¥–ø–∏—Å—å</label><input type="text" value="${escXml(p.label)}" onchange="pockets[${i}].label=this.value;rebuild()"></div>
      <div class="grid-2">
        <div class="row"><label>X</label><input type="number" value="${Math.round(p.x)}" onchange="pockets[${i}].x=parseFloat(this.value);rebuild()"></div>
        <div class="row"><label>Y</label><input type="number" value="${Math.round(p.y)}" onchange="pockets[${i}].y=parseFloat(this.value);rebuild()"></div>
        <div class="row"><label>–®</label><input type="number" value="${Math.round(p.w)}" onchange="pockets[${i}].w=parseFloat(this.value);rebuild()"></div>
        <div class="row"><label>–í</label><input type="number" value="${Math.round(p.h)}" onchange="pockets[${i}].h=parseFloat(this.value);rebuild()"></div>
      </div>
      <div class="row"><label>–¶–≤–µ—Ç</label><input type="color" value="${p.color}" onchange="pockets[${i}].color=this.value;rebuild()">
        <label>–û–±–≤.</label><input type="color" value="${p.stroke}" onchange="pockets[${i}].stroke=this.value;rebuild()"></div>
    </div>`;
            });
            el.innerHTML = html;
        }

        // ===== SNAP =====
        function getSnapTargets(di) {
            const sw = num('standW'), sh = num('standH'), hh = num('headerH'), pt = num('contentPadTop'), pb = num('contentPadBottom'), pl = num('contentPadLeft'), pr = num('contentPadRight');
            const t = { x: [], y: [] };
            // Stand edges + center
            if (chk('snapEdges')) {
                t.x.push({ pos: 0, type: 'edge' }, { pos: sw, type: 'edge' }, { pos: sw / 2, type: 'center-stand' });
                t.y.push({ pos: 0, type: 'edge' }, { pos: sh, type: 'edge' }, { pos: sh / 2, type: 'center-stand' });
            }
            // Padding lines
            if (chk('snapPadding')) {
                t.x.push({ pos: pl, type: 'padding' }, { pos: sw - pr, type: 'padding' });
                t.y.push({ pos: hh + pt, type: 'padding' }, { pos: sh - pb, type: 'padding' });
                if (hh > 0) t.y.push({ pos: hh, type: 'padding' });
            }
            // Grid
            if (chk('snapGrid') && chk('gridEnabled')) {
                const s = num('gridStep'), ox = num('gridOriginX'), oy = num('gridOriginY');
                if (s > 0) { for (let v = ox; v <= sw; v += s) t.x.push({ pos: v, type: 'grid' }); for (let v = oy; v <= sh; v += s) t.y.push({ pos: v, type: 'grid' }) }
            }
            // Pocket edges, centers, midpoints
            if (chk('snapPockets')) pockets.forEach((p, i) => {
                if (i === di) return;
                t.x.push({ pos: p.x, type: 'pocket' }, { pos: p.x + p.w, type: 'pocket' });
                t.y.push({ pos: p.y, type: 'pocket' }, { pos: p.y + p.h, type: 'pocket' });
                if (chk('snapCenter')) { t.x.push({ pos: p.x + p.w / 2, type: 'pocket-center' }); t.y.push({ pos: p.y + p.h / 2, type: 'pocket-center' }) }
                if (chk('snapMidpoints')) { t.x.push({ pos: p.x + p.w / 4, type: 'midpoint' }, { pos: p.x + 3 * p.w / 4, type: 'midpoint' }); t.y.push({ pos: p.y + p.h / 4, type: 'midpoint' }, { pos: p.y + 3 * p.h / 4, type: 'midpoint' }) }
            });
            // Gap midpoints: middles of spaces between adjacent pockets and edges
            if (chk('snapGapMid') && chk('snapPockets')) {
                const cp = pockets[di];
                const others = pockets.filter((p, i) => i !== di);
                // X gaps
                const xEdges = [{ left: -9999, right: 0 }]; // left wall
                others.forEach(p => xEdges.push({ left: p.x, right: p.x + p.w, cy: p.y + p.h / 2 }));
                xEdges.push({ left: sw, right: 9999 }); // right wall
                const xSorted = others.map(p => ({ l: p.x, r: p.x + p.w })).sort((a, b) => a.l - b.l);
                // Between left edge and first pocket (per row concept - simplified: all pockets)
                if (xSorted.length) {
                    // left wall to first
                    t.x.push({ pos: xSorted[0].l / 2, type: 'gapmid' });
                    // between consecutive
                    for (let i = 0; i < xSorted.length - 1; i++) {
                        const gap = xSorted[i + 1].l - xSorted[i].r;
                        if (gap > 1) t.x.push({ pos: xSorted[i].r + gap / 2, type: 'gapmid' });
                    }
                    // last to right wall
                    const lastR = xSorted[xSorted.length - 1].r;
                    if (sw - lastR > 1) t.x.push({ pos: lastR + (sw - lastR) / 2, type: 'gapmid' });
                }
                // Y gaps
                const ySorted = others.map(p => ({ t: p.y, b: p.y + p.h })).sort((a, b) => a.t - b.t);
                if (ySorted.length) {
                    const topEdge = hh > 0 ? hh : 0;
                    t.y.push({ pos: topEdge + (ySorted[0].t - topEdge) / 2, type: 'gapmid' });
                    for (let i = 0; i < ySorted.length - 1; i++) {
                        const gap = ySorted[i + 1].t - ySorted[i].b;
                        if (gap > 1) t.y.push({ pos: ySorted[i].b + gap / 2, type: 'gapmid' });
                    }
                    const lastB = ySorted[ySorted.length - 1].b;
                    if (sh - lastB > 1) t.y.push({ pos: lastB + (sh - lastB) / 2, type: 'gapmid' });
                }
            }
            // Symmetry: positions where pocket would be equidistant from neighbors
            if (chk('snapSymmetry') && chk('snapPockets')) {
                const cp = pockets[di] || { w: 148, h: 210 };
                const others = pockets.filter((p, i) => i !== di);
                // X symmetry
                const xWalls = [0, sw]; // stand edges
                const xBarriers = [...xWalls];
                others.forEach(p => { xBarriers.push(p.x); xBarriers.push(p.x + p.w) });
                xBarriers.sort((a, b) => a - b);
                // For each pair of consecutive barriers, the symmetric center for pocket width
                for (let i = 0; i < xBarriers.length - 1; i++) {
                    const gapStart = xBarriers[i], gapEnd = xBarriers[i + 1];
                    const gapW = gapEnd - gapStart;
                    if (gapW > cp.w + 2) {
                        const centered = gapStart + (gapW - cp.w) / 2;
                        t.x.push({ pos: centered, type: 'symmetry', label: 'left-edge' });
                        t.x.push({ pos: centered + cp.w, type: 'symmetry', label: 'right-edge' });
                        t.x.push({ pos: centered + cp.w / 2, type: 'symmetry', label: 'center' });
                    }
                }
                // Y symmetry
                const topEdge = hh > 0 ? hh : 0;
                const yBarriers = [topEdge, sh];
                others.forEach(p => { yBarriers.push(p.y); yBarriers.push(p.y + p.h) });
                yBarriers.sort((a, b) => a - b);
                for (let i = 0; i < yBarriers.length - 1; i++) {
                    const gapStart = yBarriers[i], gapEnd = yBarriers[i + 1];
                    const gapH = gapEnd - gapStart;
                    if (gapH > cp.h + 2) {
                        const centered = gapStart + (gapH - cp.h) / 2;
                        t.y.push({ pos: centered, type: 'symmetry', label: 'top-edge' });
                        t.y.push({ pos: centered + cp.h, type: 'symmetry', label: 'bottom-edge' });
                        t.y.push({ pos: centered + cp.h / 2, type: 'symmetry', label: 'center' });
                    }
                }
            }
            return t;
        }
        function snapVal(v, ts, r) { let b = null, bd = r + 1; for (const t of ts) { const d = Math.abs(v - t.pos); if (d < bd) { bd = d; b = t } } return b && bd <= r ? b : null }
        function applySnap(idx, nx, ny) {
            snapLines = []; if (!chk('snapEnabled')) return { x: nx, y: ny };
            const p = pockets[idx], r = num('snapRadius'), t = getSnapTargets(idx); let rx = nx, ry = ny;
            const badge = document.getElementById('snap-badge');
            let bsx = null, bdx = r + 1;
            for (const pt of [{ o: 0 }, { o: p.w }, { o: p.w / 2 }]) {
                const s = snapVal(nx + pt.o, t.x, r);
                if (s && Math.abs(nx + pt.o - s.pos) < bdx) { bdx = Math.abs(nx + pt.o - s.pos); bsx = { pos: s.pos - pt.o, lp: s.pos, type: s.type || '' } }
            }
            let bsy = null, bdy = r + 1;
            for (const pt of [{ o: 0 }, { o: p.h }, { o: p.h / 2 }]) {
                const s = snapVal(ny + pt.o, t.y, r);
                if (s && Math.abs(ny + pt.o - s.pos) < bdy) { bdy = Math.abs(ny + pt.o - s.pos); bsy = { pos: s.pos - pt.o, lp: s.pos, type: s.type || '' } }
            }
            if (bsx) { rx = bsx.pos; snapLines.push({ axis: 'x', pos: bsx.lp, type: bsx.type }) }
            if (bsy) { ry = bsy.pos; snapLines.push({ axis: 'y', pos: bsy.lp, type: bsy.type }) }
            badge.classList.toggle('active', !!bsx || !!bsy);
            if (bsx || bsy) {
                const types = [bsx, bsy].filter(Boolean).map(s => s.type);
                const labels = { 'center-stand': '‚äï –¶–µ–Ω—Ç—Ä —Å—Ç–µ–Ω–¥–∞', 'gapmid': '‚ñ≥ –°–µ—Ä–µ–¥–∏–Ω–∞ –ø—Ä–æ–º–µ–∂—É—Ç–∫–∞', 'symmetry': '‚öñ –°–∏–º–º–µ—Ç—Ä–∏—è', 'pocket-center': '‚óé –¶–µ–Ω—Ç—Ä –∫–∞—Ä–º–∞–Ω–∞' };
                const special = types.find(t => labels[t]);
                badge.textContent = special ? 'üß≤ ' + labels[special] : 'üß≤ –ü—Ä–∏–≤—è–∑–∫–∞';
            }
            return { x: rx, y: ry };
        }
        function applySnapResize(idx, dir, nx, ny, nw, nh) {
            snapLines = []; if (!chk('snapEnabled')) return { x: nx, y: ny, w: nw, h: nh };
            const r = num('snapRadius'), t = getSnapTargets(idx);
            if (dir.includes('e')) { const s = snapVal(nx + nw, t.x, r); if (s) { nw = s.pos - nx; snapLines.push({ axis: 'x', pos: s.pos, type: s.type || '' }) } }
            if (dir.includes('w')) { const s = snapVal(nx, t.x, r); if (s) { nw += nx - s.pos; nx = s.pos; snapLines.push({ axis: 'x', pos: s.pos, type: s.type || '' }) } }
            if (dir.includes('s')) { const s = snapVal(ny + nh, t.y, r); if (s) { nh = s.pos - ny; snapLines.push({ axis: 'y', pos: s.pos, type: s.type || '' }) } }
            if (dir.includes('n')) { const s = snapVal(ny, t.y, r); if (s) { nh += ny - s.pos; ny = s.pos; snapLines.push({ axis: 'y', pos: s.pos, type: s.type || '' }) } }
            const badge = document.getElementById('snap-badge'); badge.classList.toggle('active', snapLines.length > 0);
            if (snapLines.length) {
                const types = snapLines.map(s => s.type);
                const labels = { 'center-stand': '‚äï –¶–µ–Ω—Ç—Ä —Å—Ç–µ–Ω–¥–∞', 'gapmid': '‚ñ≥ –°–µ—Ä–µ–¥–∏–Ω–∞ –ø—Ä–æ–º–µ–∂—É—Ç–∫–∞', 'symmetry': '‚öñ –°–∏–º–º–µ—Ç—Ä–∏—è', 'pocket-center': '‚óé –¶–µ–Ω—Ç—Ä –∫–∞—Ä–º–∞–Ω–∞' };
                const special = types.find(t => labels[t]);
                badge.textContent = special ? 'üß≤ ' + labels[special] : 'üß≤ –ü—Ä–∏–≤—è–∑–∫–∞';
            }
            return { x: nx, y: ny, w: Math.max(20, nw), h: Math.max(20, nh) };
        }

        // ===== SVG TEXT =====
        function renderHeaderTextSVG(sw, hh) {
            const lines = document.getElementById('headerText').value.split('\n');
            if (!lines.length || hh <= 0) return '';
            const fh = num('headerFontH'), fw = num('headerFontW'), tc = val('headerTextColor'), ff = val('headerFont'), fb = val('headerBold');
            const pl = num('headerPadLeft'), pr = num('headerPadRight'), pt = num('headerPadTop'), pb = num('headerPadBottom');
            const lh = num('headerLineH') > 0 ? num('headerLineH') : fh * 1.3;
            const cx = pl + (sw - pl - pr) / 2, usH = (hh - pb) - pt, totH = fh + (lines.length - 1) * lh;
            const fY = pt + usH / 2 - totH / 2 + fh * 0.75;
            const sx = calcScaleX(fw, ff, fb, fh), ns = fw > 0 && Math.abs(sx - 1) > 0.001;
            let svg = ns ? `<g transform="translate(${cx},0) scale(${sx.toFixed(4)},1) translate(${-cx},0)">` : '';
            lines.forEach((l, i) => { svg += `<text x="${cx}" y="${fY + i * lh}" text-anchor="middle" font-family="${ff}" font-size="${fh}" font-weight="${fb}" fill="${tc}">${escXml(l)}</text>` });
            if (ns) svg += '</g>'; return svg;
        }
        function renderPocketLabelSVG(p) {
            const lp = val('pocketLabelPos'); if (lp === 'none' || !p.label) return '';
            const pf = val('pocketFont'), pfh = num('pocketFontH'), pfw = num('pocketFontW'), plc = val('pocketLabelColor'), plg = num('pocketLabelGap');
            const lx = p.x + p.w / 2, ly = lp === 'top' ? p.y - plg : p.y + p.h + plg + pfh;
            const sx = calcScaleX(pfw, pf, 'normal', pfh), ns = pfw > 0 && Math.abs(sx - 1) > 0.001;
            let svg = ns ? `<g transform="translate(${lx},0) scale(${sx.toFixed(4)},1) translate(${-lx},0)">` : '';
            svg += `<text x="${lx}" y="${ly}" text-anchor="middle" font-family="${pf}" font-size="${pfh}" fill="${plc}">${escXml(p.label)}</text>`;
            if (ns) svg += '</g>'; return svg;
        }

        // ===== DIMENSION LINES =====
        function renderDimensions(sw, sh) {
            if (!chk('dimEnabled') || pockets.length === 0) return '';
            const dc = val('dimColor'), dfs = num('dimFontSize'), doff = num('dimOffset'), dlw = num('dimLineWidth') || 0.5, dew = num('dimExtWidth') || 0.3;
            let svg = '';
            const arr = 2; // arrow size

            function dimLine(x1, y1, x2, y2, label, side) {
                // side: 'top','bottom','left','right' - where to place relative to objects
                const horiz = Math.abs(y1 - y2) < 0.1;
                const len = horiz ? Math.abs(x2 - x1) : Math.abs(y2 - y1);
                if (len < 1) return '';
                let s = '';
                if (horiz) {
                    const mx = (x1 + x2) / 2, my = y1;
                    const ey = side === 'top' ? my - doff : my + doff;
                    // extension lines
                    s += `<line x1="${x1}" y1="${my}" x2="${x1}" y2="${ey}" stroke="${dc}" stroke-width="${dew}"/>`;
                    s += `<line x1="${x2}" y1="${my}" x2="${x2}" y2="${ey}" stroke="${dc}" stroke-width="${dew}"/>`;
                    // dim line
                    s += `<line x1="${x1}" y1="${ey}" x2="${x2}" y2="${ey}" stroke="${dc}" stroke-width="${dlw}"/>`;
                    // arrows
                    s += `<polygon points="${x1},${ey} ${x1 + arr},${ey - arr * 0.5} ${x1 + arr},${ey + arr * 0.5}" fill="${dc}"/>`;
                    s += `<polygon points="${x2},${ey} ${x2 - arr},${ey - arr * 0.5} ${x2 - arr},${ey + arr * 0.5}" fill="${dc}"/>`;
                    // text
                    s += `<text x="${mx}" y="${ey - 2}" text-anchor="middle" font-size="${dfs}" fill="${dc}" font-family="Arial">${label}</text>`;
                } else {
                    const mx = x1, my = (y1 + y2) / 2;
                    const ex = side === 'left' ? mx - doff : mx + doff;
                    s += `<line x1="${mx}" y1="${y1}" x2="${ex}" y2="${y1}" stroke="${dc}" stroke-width="${dew}"/>`;
                    s += `<line x1="${mx}" y1="${y2}" x2="${ex}" y2="${y2}" stroke="${dc}" stroke-width="${dew}"/>`;
                    s += `<line x1="${ex}" y1="${y1}" x2="${ex}" y2="${y2}" stroke="${dc}" stroke-width="${dlw}"/>`;
                    s += `<polygon points="${ex},${y1} ${ex - arr * 0.5},${y1 + arr} ${ex + arr * 0.5},${y1 + arr}" fill="${dc}"/>`;
                    s += `<polygon points="${ex},${y2} ${ex - arr * 0.5},${y2 - arr} ${ex + arr * 0.5},${y2 - arr}" fill="${dc}"/>`;
                    if (side === 'right') {
                        s += `<text x="${ex + 2}" y="${my}" text-anchor="start" dominant-baseline="central" font-size="${dfs}" fill="${dc}" font-family="Arial">${label}</text>`;
                    } else {
                        s += `<text x="${ex - 2}" y="${my}" text-anchor="end" dominant-baseline="central" font-size="${dfs}" fill="${dc}" font-family="Arial">${label}</text>`;
                    }
                }
                return s;
            }

            const hh = num('headerH');

            // Sort pockets into rows and cols by grouping nearby coordinates
            const tolerance = 5;
            function groupBy(arr, key) {
                const groups = [];
                arr.forEach(v => { let found = groups.find(g => Math.abs(g.val - v[key]) < tolerance); if (found) found.items.push(v); else groups.push({ val: v[key], items: [v] }) });
                groups.sort((a, b) => a.val - b.val);
                return groups;
            }

            const rows = groupBy(pockets, 'y');
            const cols = groupBy(pockets, 'x');

            // Horizontal gaps (top side dims)
            if (chk('dimHGaps')) {
                const levelY = -doff;
                rows.forEach((row, ri) => {
                    const sorted = [...row.items].sort((a, b) => a.x - b.x);
                    const baseY = row.val;
                    const dimY = baseY - (ri === 0 ? doff : doff * (ri + 1));
                    // left edge to first pocket
                    if (sorted.length > 0) {
                        const f = sorted[0];
                        if (f.x > 1) svg += dimLine(0, baseY, f.x, baseY, '' + Math.round(f.x), 'top');
                    }
                    // between pockets
                    for (let i = 0; i < sorted.length - 1; i++) {
                        const a = sorted[i], b = sorted[i + 1];
                        const gap = b.x - (a.x + a.w);
                        if (gap > 1) svg += dimLine(a.x + a.w, baseY, b.x, baseY, '' + Math.round(gap), 'top');
                    }
                    // last pocket to right edge
                    if (sorted.length > 0) {
                        const l = sorted[sorted.length - 1];
                        const gap = sw - (l.x + l.w);
                        if (gap > 1) svg += dimLine(l.x + l.w, baseY, sw, baseY, '' + Math.round(gap), 'top');
                    }
                });
            }

            // Vertical gaps (left side dims)
            if (chk('dimVGaps')) {
                cols.forEach((col, ci) => {
                    const sorted = [...col.items].sort((a, b) => a.y - b.y);
                    const baseX = col.val;
                    // header/top edge to first pocket
                    if (sorted.length > 0) {
                        const f = sorted[0];
                        const topRef = hh > 0 ? hh : 0;
                        const gap = f.y - topRef;
                        if (gap > 1) svg += dimLine(baseX, topRef, baseX, f.y, '' + Math.round(gap), 'left');
                    }
                    // between pockets vertically
                    for (let i = 0; i < sorted.length - 1; i++) {
                        const a = sorted[i], b = sorted[i + 1];
                        const gap = b.y - (a.y + a.h);
                        if (gap > 1) svg += dimLine(baseX, a.y + a.h, baseX, b.y, '' + Math.round(gap), 'left');
                    }
                    // last pocket to bottom
                    if (sorted.length > 0) {
                        const l = sorted[sorted.length - 1];
                        const gap = sh - (l.y + l.h);
                        if (gap > 1) svg += dimLine(baseX, l.y + l.h, baseX, sh, '' + Math.round(gap), 'left');
                    }
                });
            }

            // Header dimensions
            if (chk('dimHeader') && hh > 0) {
                const rx = sw + doff;
                // Header height
                svg += dimLine(sw, 0, sw, hh, '–®–∞–ø–∫–∞: ' + Math.round(hh), 'right');
                // Remaining height
                svg += dimLine(sw + doff * 2.5, hh, sw + doff * 2.5, sh, '' + Math.round(sh - hh), 'right');
                // Full stand
                svg += dimLine(sw + doff * 4, 0, sw + doff * 4, sh, '–í—Å–µ–≥–æ: ' + Math.round(sh), 'right');
            }

            // Header text dimensions
            if (chk('dimHeaderText') && hh > 0) {
                const fh = num('headerFontH'), fw = num('headerFontW');
                const pt = num('headerPadTop'), pb = num('headerPadBottom');
                const lhVal = num('headerLineH') > 0 ? num('headerLineH') : fh * 1.3;
                const lines = document.getElementById('headerText').value.split('\n');
                const totH = fh + (lines.length - 1) * lhVal;
                const usH = (hh - pb) - pt;
                const textTop = pt + usH / 2 - totH / 2;
                const textBot = textTop + totH;

                const lx = -doff;
                // top of header to text
                if (textTop > 1) svg += dimLine(0, 0, 0, textTop, '' + Math.round(textTop), 'left');
                // text block height
                svg += dimLine(-doff * 2.5, textTop, -doff * 2.5, textBot, '–í—ã—Å.—Ç–µ–∫—Å—Ç–∞: ' + Math.round(totH), 'left');
                // text to bottom of header
                const btm = hh - textBot;
                if (btm > 1) svg += dimLine(0, textBot, 0, hh, '' + Math.round(Math.round(btm)), 'left');

                // Char height & width at bottom
                const cw = fw > 0 ? fw : Math.round(measureCharWidth(val('headerFont'), val('headerBold'), fh) * 10) / 10;
                svg += `<text x="${sw / 2}" y="${sh + doff}" text-anchor="middle" font-size="${dfs}" fill="${dc}" font-family="Arial">–ë—É–∫–≤—ã: –≤—ã—Å.=${fh}–º–º${fw > 0 ? ', —à–∏—Ä.=' + fw + '–º–º' : ', —à–∏—Ä.‚âà' + cw + '–º–º'}</text>`;
            }

            return svg;
        }

        // ===== BUILD SVG =====
        function buildSVG(sw, sh, z, withGrid, withDims) {
            const sc = val('standColor'), sr = num('standRadius'), hh = num('headerH'), hc = val('headerColor');
            const bOn = chk('borderEnabled'), bw = bOn ? num('borderW') : 0, bc = val('borderColor'), bi = num('borderInset');
            // Extra margin for dimension lines (increased to 12x to prevent clipping)
            const dm = withDims && chk('dimEnabled') ? num('dimOffset') * 12 : 0;
            const vbX = -dm, vbY = -dm, vbW = sw + dm * 2, vbH = sh + dm * 2;

            let svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${vbW * MM2PX * z}" height="${vbH * MM2PX * z}" viewBox="${vbX} ${vbY} ${vbW} ${vbH}" overflow="visible" style="position:absolute;top:0;left:0;overflow:visible;">`;
            svg += `<rect x="0" y="0" width="${sw}" height="${sh}" rx="${sr}" ry="${sr}" fill="${sc}"/>`;

            if (withGrid && chk('gridEnabled')) {
                const step = num('gridStep'), major = num('gridMajor'), gc = val('gridColor'), gmc = val('gridMajorColor'), ox = num('gridOriginX'), oy = num('gridOriginY');
                if (step > 0) { let idx = 0; for (let x = ox; x <= sw; x += step) { svg += `<line x1="${x}" y1="0" x2="${x}" y2="${sh}" stroke="${idx % major === 0 ? gmc : gc}" stroke-width="${idx % major === 0 ? 0.8 : 0.3}"/>`; idx++ } idx = 0; for (let y = oy; y <= sh; y += step) { svg += `<line x1="0" y1="${y}" x2="${sw}" y2="${y}" stroke="${idx % major === 0 ? gmc : gc}" stroke-width="${idx % major === 0 ? 0.8 : 0.3}"/>`; idx++ } }
            }

            if (hh > 0) {
                svg += `<clipPath id="hdrClip"><rect x="0" y="0" width="${sw}" height="${sh}" rx="${sr}" ry="${sr}"/></clipPath>`;
                svg += `<rect x="0" y="0" width="${sw}" height="${hh}" fill="${hc}" clip-path="url(#hdrClip)"/>`;
                svg += renderHeaderTextSVG(sw, hh);
            }
            pockets.forEach(p => {
                svg += `<rect x="${p.x}" y="${p.y}" width="${p.w}" height="${p.h}" rx="${p.radius}" ry="${p.radius}" fill="${p.color}" stroke="${p.stroke}" stroke-width="${p.strokeW}"/>`;
                svg += renderPocketLabelSVG(p);
            });
            if (bw > 0) svg += `<rect x="${bi + bw / 2}" y="${bi + bw / 2}" width="${sw - 2 * bi - bw}" height="${sh - 2 * bi - bw}" rx="${Math.max(0, sr - bi)}" fill="none" stroke="${bc}" stroke-width="${bw}"/>`;

            if (withDims) svg += renderDimensions(sw, sh);
            svg += '</svg>'; return svg;
        }

        function buildOverlays(sw, sh, z) {
            const dm = chk('dimEnabled') ? num('dimOffset') * 12 : 0;
            let html = ''; const s = MM2PX * z;
            pockets.forEach((p, i) => {
                const sel = i === selectedPocket;
                html += `<div class="pocket-overlay ${sel ? 'selected' : ''}" data-idx="${i}" style="left:${(p.x + dm) * s}px;top:${(p.y + dm) * s}px;width:${p.w * s}px;height:${p.h * s}px;">`;
                if (sel) ['se', 'sw', 'ne', 'nw'].forEach(d => html += `<div class="resize-handle ${d}" data-dir="${d}"></div>`);
                html += '</div>';
            });
            snapLines.forEach(sl => {
                const cls = sl.type ? ' snap-' + sl.type : '';
                if (sl.axis === 'x') {
                    html += `<div class="snap-line snap-line-v${cls}" style="left:${(sl.pos + dm) * s}px;"></div>`;
                    // Marker at pocket position
                    if (sl.type === 'center-stand') html += `<div class="snap-marker snap-marker-center" style="left:${(sl.pos + dm) * s - 7}px;top:10px;font-size:16px;">‚äï</div>`;
                    if (sl.type === 'gapmid') html += `<div class="snap-marker snap-marker-gapmid" style="left:${(sl.pos + dm) * s - 5}px;top:10px;font-size:14px;">‚ñ≥</div>`;
                    if (sl.type === 'symmetry') html += `<div class="snap-marker snap-marker-symmetry" style="left:${(sl.pos + dm) * s - 5}px;top:10px;font-size:14px;">‚öñ</div>`;
                } else {
                    html += `<div class="snap-line snap-line-h${cls}" style="top:${(sl.pos + dm) * s}px;"></div>`;
                    if (sl.type === 'center-stand') html += `<div class="snap-marker snap-marker-center" style="top:${(sl.pos + dm) * s - 7}px;left:10px;font-size:16px;">‚äï</div>`;
                    if (sl.type === 'gapmid') html += `<div class="snap-marker snap-marker-gapmid" style="top:${(sl.pos + dm) * s - 5}px;left:10px;font-size:14px;">‚ñ≥</div>`;
                    if (sl.type === 'symmetry') html += `<div class="snap-marker snap-marker-symmetry" style="top:${(sl.pos + dm) * s - 5}px;left:10px;font-size:14px;">‚öñ</div>`;
                }
            });
            return html;
        }

        function rebuild() {
            const sw = num('standW'), sh = num('standH');
            const dm = chk('dimEnabled') ? num('dimOffset') * 12 : 0;
            const wrapper = document.getElementById('canvas-wrapper');
            wrapper.style.width = ((sw + dm * 2) * MM2PX * zoom) + 'px';
            wrapper.style.height = ((sh + dm * 2) * MM2PX * zoom) + 'px';
            wrapper.innerHTML = buildSVG(sw, sh, zoom, true, true) + buildOverlays(sw, sh, zoom);
            updatePan();
            renderPocketList();
            // Auto-scroll to selected pocket in list
            if (selectedPocket >= 0) {
                const selEl = document.querySelector('.pocket-item.selected');
                if (selEl) selEl.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
            }
            document.getElementById('zoomInfo').textContent = `${Math.round(zoom * 100)}% | ${sw}√ó${sh}`;
            attachDragHandlers();
            updateTypeCounts();
            const g = document.getElementById('btnGrid'), s = document.getElementById('btnSnap'), d = document.getElementById('btnDim'), pb = document.getElementById('btnPan');
            g.style.background = chk('gridEnabled') ? '#0f3460' : '#333'; g.style.color = chk('gridEnabled') ? '#00e5ff' : '#aaa';
            s.style.background = chk('snapEnabled') ? '#0f3460' : '#333'; s.style.color = chk('snapEnabled') ? '#00e5ff' : '#aaa';
            d.style.background = chk('dimEnabled') ? '#0f3460' : '#333'; d.style.color = chk('dimEnabled') ? '#00e5ff' : '#aaa';
            pb.style.background = panMode ? '#0f3460' : '#333'; pb.style.color = panMode ? '#00e5ff' : '#aaa';
        }

        // ===== DRAG =====
        function attachDragHandlers() {
            document.getElementById('canvas-wrapper').querySelectorAll('.pocket-overlay').forEach(ov => {
                ov.addEventListener('mousedown', function (e) {
                    if (isPanActive()) return;
                    const idx = parseInt(this.dataset.idx); selectedPocket = idx;
                    const handle = e.target.closest('.resize-handle'), p = pockets[idx];
                    if (handle) dragState = { type: 'resize', idx, dir: handle.dataset.dir, startX: e.clientX, startY: e.clientY, origX: p.x, origY: p.y, origW: p.w, origH: p.h };
                    else dragState = { type: 'move', idx, startX: e.clientX, startY: e.clientY, origX: p.x, origY: p.y };
                    e.preventDefault(); rebuild();
                });
                ov.addEventListener('touchstart', function (e) {
                    if (isPanActive()) return;
                    const t = e.touches[0]; if (!t) return;
                    const idx = parseInt(this.dataset.idx);
                    const p = pockets[idx]; if (!p) return;
                    selectedPocket = idx;
                    touchDragState = {
                        idx: idx, startX: t.clientX, startY: t.clientY,
                        origX: p.x, origY: p.y, overlay: this
                    };
                    this.classList.add('selected');
                    this.style.borderColor = '#e94560';
                    this.style.borderStyle = 'solid';
                    e.preventDefault();
                    e.stopPropagation();
                }, { passive: false });
            });
        }
        document.addEventListener('mousemove', function (e) {
            if (!dragState) return; const s = MM2PX * zoom, dx = (e.clientX - dragState.startX) / s, dy = (e.clientY - dragState.startY) / s, p = pockets[dragState.idx];
            if (dragState.type === 'move') { let nx = Math.max(0, dragState.origX + dx), ny = Math.max(0, dragState.origY + dy); const sn = applySnap(dragState.idx, nx, ny); p.x = sn.x; p.y = sn.y }
            else {
                const d = dragState.dir; let nx = dragState.origX, ny = dragState.origY, nw = dragState.origW, nh = dragState.origH;
                if (d.includes('e')) nw += dx; if (d.includes('s')) nh += dy; if (d.includes('w')) { nx += dx; nw -= dx } if (d.includes('n')) { ny += dy; nh -= dy }
                const sn = applySnapResize(dragState.idx, d, nx, ny, nw, nh); p.x = sn.x; p.y = sn.y; p.w = sn.w; p.h = sn.h
            }
            rebuild();
        });
        document.addEventListener('mouseup', function () { if (dragState) { dragState = null; snapLines = []; document.getElementById('snap-badge').classList.remove('active'); rebuild() } });
        document.getElementById('canvas-wrapper').addEventListener('mousedown', function (e) { if (e.target === this || ['svg', 'rect', 'line'].includes(e.target.tagName)) { selectedPocket = -1; rebuild() } });

        // ===== ZOOM =====
        function zoomIn() { zoom = Math.min(3, zoom * 1.2); rebuild() }
        function zoomOut() { zoom = Math.max(0.05, zoom / 1.2); rebuild() }
        function zoomReset() { zoom = 1; centerView(); rebuild() }
        function zoomFit() { const c = document.getElementById('canvas-container'), dm = chk('dimEnabled') ? num('dimOffset') * 12 : 0; zoom = Math.min((c.clientWidth - 60) / ((num('standW') + dm * 2) * MM2PX), (c.clientHeight - 60) / ((num('standH') + dm * 2) * MM2PX), 2); centerView(); rebuild() }

        // ===== PAN =====
        function togglePanMode() { panMode = !panMode; const c = document.getElementById('canvas-container'); c.classList.toggle('pan-mode', panMode); rebuild() }
        function updatePan() { const w = document.getElementById('canvas-wrapper'); w.style.left = panX + 'px'; w.style.top = panY + 'px'; const tsl = document.getElementById('touch-snap-layer'); if (tsl) { tsl.style.left = panX + 'px'; tsl.style.top = panY + 'px' } }
        function centerView() {
            const c = document.getElementById('canvas-container'), dm = chk('dimEnabled') ? num('dimOffset') * 12 : 0;
            const ww = (num('standW') + dm * 2) * MM2PX * zoom, wh = (num('standH') + dm * 2) * MM2PX * zoom;
            panX = (c.clientWidth - ww) / 2; panY = (c.clientHeight - wh) / 2; updatePan();
        }
        function isPanActive() { return panMode || spaceDown }

        // Pan via mouse on canvas-container
        (function () {
            const cc = document.getElementById('canvas-container');
            cc.addEventListener('mousedown', function (e) {
                // Middle mouse button always pans
                if (e.button === 1 || (isPanActive() && e.button === 0)) {
                    panState = { startX: e.clientX, startY: e.clientY, origPanX: panX, origPanY: panY };
                    cc.classList.add('panning'); e.preventDefault();
                }
            });
            document.addEventListener('mousemove', function (e) {
                if (!panState) return;
                panX = panState.origPanX + (e.clientX - panState.startX);
                panY = panState.origPanY + (e.clientY - panState.startY);
                updatePan();
            });
            document.addEventListener('mouseup', function (e) {
                if (panState) { panState = null; cc.classList.remove('panning') }
            });

            // Wheel zoom (Ctrl+wheel) or pan (wheel without Ctrl)
            cc.addEventListener('wheel', function (e) {
                e.preventDefault();
                if (e.ctrlKey) {
                    // Zoom toward cursor
                    const rect = cc.getBoundingClientRect();
                    const mx = e.clientX - rect.left, my = e.clientY - rect.top;
                    const oldZoom = zoom;
                    if (e.deltaY < 0) zoom = Math.min(3, zoom * 1.1);
                    else zoom = Math.max(0.05, zoom / 1.1);
                    const scale = zoom / oldZoom;
                    panX = mx - (mx - panX) * scale;
                    panY = my - (my - panY) * scale;
                    rebuild();
                } else {
                    // Pan with scroll
                    panX -= e.deltaX || 0;
                    panY -= e.deltaY || 0;
                    updatePan();
                }
            }, { passive: false });

            // Space key for temporary pan mode
            document.addEventListener('keydown', function (e) {
                if (['INPUT', 'TEXTAREA', 'SELECT'].includes(e.target.tagName)) return;
                if (e.code === 'Space' && !spaceDown) { spaceDown = true; cc.classList.add('pan-mode'); e.preventDefault() }
            });
            document.addEventListener('keyup', function (e) {
                if (e.code === 'Space') { spaceDown = false; if (!panMode) cc.classList.remove('pan-mode') }
            });
        })();

        // ===== EXPORT =====
        function showExport() { document.getElementById('exportModal').classList.add('active') }
        function closeExport() { document.getElementById('exportModal').classList.remove('active') }
        function generateExportSVG() {
            const sw = num('standW'), sh = num('standH');
            const sc = val('standColor'), sr = num('standRadius'), hh = num('headerH'), hc = val('headerColor');
            const bOn = chk('borderEnabled'), bw = bOn ? num('borderW') : 0, bc = val('borderColor'), bi = num('borderInset');
            let svg = `<?xml version="1.0" encoding="UTF-8"?>\n`;
            svg += `<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="${sw}mm" height="${sh}mm" viewBox="0 0 ${sw} ${sh}">\n`;
            svg += `<rect x="0" y="0" width="${sw}" height="${sh}" rx="${sr}" ry="${sr}" fill="${sc}"/>\n`;
            if (hh > 0) {
                if (sr > 0) {
                    const r = Math.min(sr, hh);
                    svg += `<path d="M${r},0 L${sw - r},0 Q${sw},0 ${sw},${r} L${sw},${hh} L0,${hh} L0,${r} Q0,0 ${r},0 Z" fill="${hc}"/>\n`;
                } else {
                    svg += `<rect x="0" y="0" width="${sw}" height="${hh}" fill="${hc}"/>\n`;
                }
                const lines = document.getElementById('headerText').value.split('\n');
                if (lines.length && lines[0].trim()) {
                    const fh = num('headerFontH'), tc = val('headerTextColor'), ff = val('headerFont'), fb = val('headerBold');
                    const pl = num('headerPadLeft'), pr = num('headerPadRight'), pt = num('headerPadTop'), pb = num('headerPadBottom');
                    const lh = num('headerLineH') > 0 ? num('headerLineH') : fh * 1.3;
                    const cx = pl + (sw - pl - pr) / 2, usH = (hh - pb) - pt, totH = fh + (lines.length - 1) * lh;
                    const fY = pt + usH / 2 - totH / 2 + fh * 0.75;
                    lines.forEach((l, i) => {
                        if (!l.trim()) return;
                        svg += `<text x="${cx}" y="${fY + i * lh}" text-anchor="middle" font-family="${ff}" font-size="${fh}" font-weight="${fb}" fill="${tc}">${escXml(l)}</text>\n`;
                    });
                }
            }
            pockets.forEach(p => {
                svg += `<rect x="${p.x}" y="${p.y}" width="${p.w}" height="${p.h}"`;
                if (p.radius > 0) svg += ` rx="${p.radius}" ry="${p.radius}"`;
                svg += ` fill="${p.color}" stroke="${p.stroke}" stroke-width="${p.strokeW}"/>\n`;
            });
            const lp = val('pocketLabelPos');
            if (lp !== 'none') {
                const pf = val('pocketFont'), pfh = num('pocketFontH'), plc = val('pocketLabelColor'), plg = num('pocketLabelGap');
                pockets.forEach(p => {
                    if (!p.label) return;
                    const lx = p.x + p.w / 2;
                    const ly = lp === 'top' ? p.y - plg : p.y + p.h + plg + pfh;
                    svg += `<text x="${lx}" y="${ly}" text-anchor="middle" font-family="${pf}" font-size="${pfh}" fill="${plc}">${escXml(p.label)}</text>\n`;
                });
            }
            if (bw > 0) {
                svg += `<rect x="${bi + bw / 2}" y="${bi + bw / 2}" width="${sw - 2 * bi - bw}" height="${sh - 2 * bi - bw}"`;
                if (sr > bi) svg += ` rx="${sr - bi}" ry="${sr - bi}"`;
                svg += ` fill="none" stroke="${bc}" stroke-width="${bw}"/>\n`;
            }
            svg += '</svg>'; return svg;
        }
        function download(c, f, m) { const b = new Blob([c], { type: m }), a = document.createElement('a'); a.href = URL.createObjectURL(b); a.download = f; a.click() }
        function exportSVG() { download(generateExportSVG(), 'stand.svg', 'image/svg+xml'); closeExport() }
        function exportPNG() {
            const sw = num('standW'), sh = num('standH'), svg = generateExportSVG(), canvas = document.createElement('canvas'), scale = 3;
            canvas.width = sw * MM2PX * scale; canvas.height = sh * MM2PX * scale;
            const ctx = canvas.getContext('2d'), img = new Image(), url = URL.createObjectURL(new Blob([svg], { type: 'image/svg+xml;charset=utf-8' }));
            img.onload = function () { ctx.drawImage(img, 0, 0, canvas.width, canvas.height); canvas.toBlob(b => { const a = document.createElement('a'); a.href = URL.createObjectURL(b); a.download = 'stand.png'; a.click() }); URL.revokeObjectURL(url) }; img.src = url; closeExport()
        }
        function exportPDF() { const svg = generateExportSVG(), w = window.open('', '_blank'); w.document.write(`<!DOCTYPE html><html><head><title>–°—Ç–µ–Ω–¥</title><style>@page{size:${num('standW')}mm ${num('standH')}mm;margin:0}body{margin:0}</style></head><body>${svg}</body></html>`); w.document.close(); setTimeout(() => w.print(), 500); closeExport() }

        // ===== KEYBOARD =====
        document.addEventListener('keydown', function (e) {
            if (['INPUT', 'TEXTAREA', 'SELECT'].includes(e.target.tagName)) return;
            if (selectedPocket < 0) return; const p = pockets[selectedPocket], step = e.shiftKey ? 10 : 1;
            if (e.key === 'ArrowLeft') { p.x -= step; rebuild(); e.preventDefault() }
            if (e.key === 'ArrowRight') { p.x += step; rebuild(); e.preventDefault() }
            if (e.key === 'ArrowUp') { p.y -= step; rebuild(); e.preventDefault() }
            if (e.key === 'ArrowDown') { p.y += step; rebuild(); e.preventDefault() }
            if (e.key === 'Delete') { removePocket(selectedPocket); e.preventDefault() }
            if (e.key === 'r' || e.key === '–∫') { togglePocketOrientation(selectedPocket); e.preventDefault() }
        });

        window.addEventListener('load', () => { autoGrid(); zoomFit(); centerView() });

        // ===== TOUCH: snap lines renderer =====
        function syncTouchSnapLayer() {
            // Sync size and position with canvas-wrapper
            const wrapper = document.getElementById('canvas-wrapper');
            const layer = document.getElementById('touch-snap-layer');
            if (!wrapper || !layer) return;
            layer.style.width = wrapper.style.width;
            layer.style.height = wrapper.style.height;
            layer.style.left = wrapper.style.left;
            layer.style.top = wrapper.style.top;
        }

        function renderTouchSnapLines() {
            const layer = document.getElementById('touch-snap-layer');
            if (!layer) return;
            syncTouchSnapLayer();
            const s = MM2PX * zoom;
            const dm = chk('dimEnabled') ? num('dimOffset') * 12 : 0;
            let html = '';
            snapLines.forEach(sl => {
                const cls = sl.type ? ' snap-' + sl.type : '';
                if (sl.axis === 'x') {
                    html += `<div class="snap-line snap-line-v${cls}" style="position:absolute;left:${(sl.pos + dm) * s}px;top:0;bottom:0;width:1px;"></div>`;
                    if (sl.type === 'center-stand') html += `<div class="snap-marker snap-marker-center" style="position:absolute;left:${(sl.pos + dm) * s - 7}px;top:10px;font-size:16px;">‚äï</div>`;
                    if (sl.type === 'gapmid') html += `<div class="snap-marker snap-marker-gapmid" style="position:absolute;left:${(sl.pos + dm) * s - 5}px;top:10px;font-size:14px;">‚ñ≥</div>`;
                    if (sl.type === 'symmetry') html += `<div class="snap-marker snap-marker-symmetry" style="position:absolute;left:${(sl.pos + dm) * s - 5}px;top:10px;font-size:14px;">‚öñ</div>`;
                } else {
                    html += `<div class="snap-line snap-line-h${cls}" style="position:absolute;top:${(sl.pos + dm) * s}px;left:0;right:0;height:1px;"></div>`;
                    if (sl.type === 'center-stand') html += `<div class="snap-marker snap-marker-center" style="position:absolute;top:${(sl.pos + dm) * s - 7}px;left:10px;font-size:16px;">‚äï</div>`;
                    if (sl.type === 'gapmid') html += `<div class="snap-marker snap-marker-gapmid" style="position:absolute;top:${(sl.pos + dm) * s - 5}px;left:10px;font-size:14px;">‚ñ≥</div>`;
                    if (sl.type === 'symmetry') html += `<div class="snap-marker snap-marker-symmetry" style="position:absolute;top:${(sl.pos + dm) * s - 5}px;left:10px;font-size:14px;">‚öñ</div>`;
                }
            });
            layer.innerHTML = html;
            const badge = document.getElementById('snap-badge');
            if (badge) badge.classList.toggle('active', snapLines.length > 0);
        }

        function clearTouchSnapLines() {
            const layer = document.getElementById('touch-snap-layer');
            if (layer) layer.innerHTML = '';
            const badge = document.getElementById('snap-badge');
            if (badge) badge.classList.remove('active');
        }

        // ===== TOUCH: document-level move/end =====
        document.addEventListener('touchmove', function(e) {
            if (!touchDragState) return;
            const t = e.touches[0]; if (!t) return;
            const s = MM2PX * zoom;
            const dx = (t.clientX - touchDragState.startX) / s;
            const dy = (t.clientY - touchDragState.startY) / s;
            const p = pockets[touchDragState.idx];
            if (!p) return;
            const nx = Math.max(0, touchDragState.origX + dx);
            const ny = Math.max(0, touchDragState.origY + dy);
            const sn = applySnap(touchDragState.idx, nx, ny);
            p.x = sn.x; p.y = sn.y;
            const dm = (chk('dimEnabled') ? num('dimOffset') * 12 : 0);
            const ov = touchDragState.overlay;
            if (ov) {
                ov.style.left = ((p.x + dm) * s) + 'px';
                ov.style.top = ((p.y + dm) * s) + 'px';
            }
            renderTouchSnapLines();
            e.preventDefault();
        }, { passive: false });

        document.addEventListener('touchend', function() {
            if (!touchDragState) return;
            touchDragState = null;
            snapLines = [];
            clearTouchSnapLines();
            rebuild();
        });
        document.addEventListener('touchcancel', function() {
            if (!touchDragState) return;
            touchDragState = null;
            snapLines = [];
            clearTouchSnapLines();
            rebuild();
        });

        // ===== TOUCH: pan when Hand tool active =====
        (function() {
            const cc = document.getElementById('canvas-container');
            if (!cc) return;
            let touchPanState = null;
            cc.addEventListener('touchstart', function(e) {
                if (touchDragState) return;
                if (!isPanActive()) return;
                const t = e.touches[0]; if (!t) return;
                touchPanState = { startX: t.clientX, startY: t.clientY, origPanX: panX, origPanY: panY };
                cc.classList.add('panning');
                e.preventDefault();
            }, { passive: false });
            cc.addEventListener('touchmove', function(e) {
                if (!touchPanState) return;
                const t = e.touches[0]; if (!t) return;
                panX = touchPanState.origPanX + (t.clientX - touchPanState.startX);
                panY = touchPanState.origPanY + (t.clientY - touchPanState.startY);
                updatePan();
                e.preventDefault();
            }, { passive: false });
            cc.addEventListener('touchend', function() {
                if (touchPanState) { touchPanState = null; cc.classList.remove('panning') }
            });
        })();

    </script>
</body>

</html>